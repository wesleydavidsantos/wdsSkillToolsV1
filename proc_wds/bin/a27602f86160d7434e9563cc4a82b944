#!/bin/bash
# proccessMsgTelegram
# Processa cada mensagem enviada
#	- Args
#		$1 - json contendo a mensagem
startTelegram()
{
	# Posição do script
	tracker_app 'startTelegram'
	
	local msg="${1}"
	
	local update_id=$(echo "${msg}" | jq -r ".update_id")
	
	
	# Atribuí as variáveis globais os valores da mensagem enviada por telegram
	WDS_TELEGRAM_UPDATE_ID=${update_id}
	WDS_TELEGRAM_USER_CHAT_ID=$(echo "${msg}" | jq -r ".message.chat.id")
	WDS_TELEGRAM_USER_FIRST_NAME=$(echo "${msg}" | jq -r ".message.chat.first_name")
	WDS_TELEGRAM_USER_LAST_NAME=$(echo "${msg}" | jq -r ".message.chat.last_name")
	WDS_TELEGRAM_USER_MSG_ID=$(echo "${msg}" | jq -r ".message.message_id")
	WDS_TELEGRAM_USER_MSG=$(echo "${msg}" | jq -r ".message.text")
	
	# Verifica se a consulta possui anexo
	if [ "${WDS_TELEGRAM_USER_MSG}" = 'null' ]; then
		WDS_TELEGRAM_USER_MSG=$(echo "${msg}" | jq -r ".message.caption")
	fi
	
	
	# Verifica se existe anexo na mensagem
	WDS_TELEGRAM_DOCUMENT_FILE_NAME=$(echo "${msg}" | jq -r ".message.document.file_name")
	WDS_TELEGRAM_DOCUMENT_MIME_TYPE=$(echo "${msg}" | jq -r ".message.document.mime_type")
	WDS_TELEGRAM_DOCUMENT_FILE_ID=$(echo "${msg}" | jq -r ".message.document.file_id")
	WDS_TELEGRAM_DOCUMENT_FILE_SIZE=$(echo "${msg}" | jq -r ".message.document.file_size")
	
				
	###########################################
	# A partir daqui é minha responsabilidade #
	###########################################
	
	#writeLog "Telegram Mensagem - update_id ${update_id} - é minha responsabilidade"
	
	# Verifica se é para ativar o debug
	is_debug
	
	# Realiza a autenticação do usuário
	telegramAuthUser
	
	# Verifica se a permissão é aprovada
	if [ $? = 1 ]; then
	
		writeLog "Permissão negada, usuário ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"			
		exit 1
		
	fi		
	
	
	writeLog "Iniciando a interação com o usuário ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
	
	# Pega o nível de acesso do telegram
	WDS_TELEGRAM_LEVEL_USER=`echo $( telegramGetLevelAccessUser )`
	
	# Verifica se é uma chamada para todas as aplicações
	if [ "$( telegramArgMenu 1 )" = 'all' ]; then
		WDS_TELEGRAM_TYPE_CALL='ALL'
	fi

	# Verifica se a chamada é vinda de um cliente, se sim ele não pode enviar o comando all
	if [ "${WDS_TELEGRAM_LEVEL_USER}" = 'CLIENTE' ]; then
		
		# Verifica se é um comando para todos os clientes
		if [ "${WDS_TELEGRAM_TYPE_CALL}" = 'ALL' ]; then
		
			writeLog "Comando all inválido"
			show "Comando all inválido"
			
			exit 1
			
		fi
		
		# Verifica se é um comando de PIN, para cliente ele é inválido, pois um cliente já trabalha desta forma
		if [ "$( telegramArgMenu 1 )" = 'pin' ]; then
		
			writeLog "Comando pin inválido"
			show "Comando pin inválido"
			
			exit 1
			
		fi
		
	fi
	
	# Inicializa a interação com as informações do usuário
	telegramInteract		

}

# telegramGetLevelAccessUser
# Pega o nível de acesso do usuário que está acessando
telegramGetLevelAccessUser()
{	
	# Criptografa a chave de acesso do usuário
	local chat_id_cript=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID}" )
	
	local level_access_cript
	local level_access='NULL'	
	
	# Verifica se o usuário está cadastrado
	if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${chat_id_cript}" > /dev/null 2>&1; then
		
		local user_info=`echo $( cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${chat_id_cript}" )`
		
		for lvl in 'ADMIN' 'ANALISTA' 'DBA' 'CLIENTE'; do
			
			# Criptografa o nível de acesso para realizar a consulta
			level_access_cript=$( encrypt "${lvl}" )
		
			# Verifica o nível de acesso do usuário
			if echo ${user_info}|grep "${level_access_cript}" > /dev/null 2>&1; then
				level_access="${lvl}"
				break				
			fi
		
		done
		
	fi
	
	echo "${level_access}"
		
	return 0
}

# telegramAccessLevel
# Verifica se o nível de acesso do usuário é permitido para a ação solicitada
telegramAccessLevel()
{
	# Posição do script
	tracker_app 'telegramAccessLevel'

	# Recebe como parâmetro o nível de permissão requerida para acesso
	local level_required="${1^^}"
	
	
	case ${level_required} in
		
		# Level ADMIN
		ADMIN)
			# Criptografa o status da permissão e verifica se ele é aprovado
			level_required_cript=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ${level_required}" )
	
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript}" > /dev/null 2>&1; then
					return 0
			fi
		;;
		
		# Level DBA
		DBA)
			
			# Criptografa o status da permissão e verifica se ele é aprovado
			level_required_cript_admin=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ADMIN" )
			level_required_cript=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ${level_required}" )
		
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript_admin}" > /dev/null 2>&1; then
				return 0
			fi
			
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript}" > /dev/null 2>&1; then
				return 0
			fi
		;;
		
		# Level ANALISTA
		ANALISTA)
			
			# Criptografa o status da permissão e verifica se ele é aprovado
			level_required_cript_admin=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ADMIN" )
			level_required_cript_dba=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} DBA" )
			level_required_cript=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ${level_required}" )
		
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript_admin}" > /dev/null 2>&1; then
				return 0
			fi
			
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript_dba}" > /dev/null 2>&1; then
				return 0
			fi
			
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript}" > /dev/null 2>&1; then
				return 0
			fi
		;;
		
		# Level CLIENTE
		CLIENTE)
			
			# Criptografa o status da permissão e verifica se ele é aprovado
			level_required_cript_admin=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ADMIN" )
			level_required_cript_dba=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} DBA" )
			level_required_cript_startup=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ANALISTA" )
			level_required_cript=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ${level_required}" )
		
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript_admin}" > /dev/null 2>&1; then
				return 0
			fi
			
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript_dba}" > /dev/null 2>&1; then
				return 0
			fi
			
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript_startup}" > /dev/null 2>&1; then
				return 0
			fi
			
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript}" > /dev/null 2>&1; then
				return 0
			fi
		;;
		
		*)
			writeLog "Permissão não existe: ${level_required}"
			show "Permissão não existe: ${level_required}"
		;;
	esac	
	
	# Permissão Negada
	writeLog "Nível de acesso negado do usuário ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
	
	show "Você não possui privilégio suficiente para está ação."
	
	exit 1			
	
}

# telegramAuthUser
# Realiza a autenticação do usuário para uso da aplicação pelo telegram
telegramAuthUser()
{
	# Posição do script
	tracker_app 'telegramAuthUser'
	
	# Status da autorização
	local is_permission='false'
	
	# Criptografa a chave do usuário para verifica se ele já foi cadastrado
	local chat_id_cript=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID}" )

	# Verifica se é um usuário novo, do tipo MASTER
	if ! cat "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}" |grep "${chat_id_cript}" > /dev/null 2>&1; then
		
		# Verifica se o usuário que está sendo cadastrado é o usuário Master da Aplicação
		if [ "${WDS_TELEGRAM_USER_MASTER}" = "${WDS_TELEGRAM_USER_CHAT_ID}" ]; then
			
			# Cadastra o usuário
			userAdd 'ADMIN'
			
			#show 'Usuário Master cadastrado com sucesso'
						
		fi
		
	fi
	
	################################################################
	# A partir daqui a aplicação já deve estar instala com sucesso #
	################################################################
	
	# Verifica se a aplicação já foi instalada ou se está solicitando a instalação da aplicação
	if [ "$( telegramGetArgs 2 )" != "START_LICENSE" ]; then
		
		# Realiza a chamada para validar a instalação da aplicação
		__VALID_LICENSE__APP__
	
	fi
	
		
	# Verifica se é um usuário novo com uma chave válida para cadastro
	if ! cat "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}" |grep "${chat_id_cript}" > /dev/null 2>&1; then
			
		# Verifica se a chamada é para criar um novo usuário, esse novo usuário só é permitido através de uma chave
		local create_user=$( telegramArgMenu 1 )
		if [ "${create_user}" = 'wds' ]; then
				
			writeLog "Acesso aprovado do usuário ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}, para se cadastrar no sistema"
				
			return 0
			
		else
		
			writeLog "Usuário desconhecido, acesso negado. ${create_user}"
			
			show "Usuário desconhecido, acesso negado."
			
			exit 1
			
		fi		
		
	fi
		
		
	#########################################################################################################
	# Se entrou aqui, então já é um usuário cadastrado, desta forma verifica se ele tem permissão de acesso #
	#########################################################################################################
	
	
	writeLog "Verifica o nível de acesso do usuário"
	
	# Verifica se é um usuário cadastrado, senão o acesso é negado
	if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${chat_id_cript}" > /dev/null 2>&1; then
	
		writeLog "Acesso aprovado"
		writeLog "	- ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
		writeLog "	- Nível de acesso: "`echo $( telegramGetLevelAccessUser )`
				
		return 0
	
	fi
	
	# Acesso negado
	writeLog "Acesso negado do usuário ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"

	show "Acesso negado"

	exit 1			
	
}






# telegramGetArgs
# Pega cada argumento repassado na mensagem do usuário, os argumentos são separados por espaço em branco
#	- Args
#		$1 - json contendo a mensagem
telegramGetArgs()
{
	# Posição do argumento a ser retornado
	local position="${1}"
	
	# Pega o nível de acesso do telegram
	WDS_TELEGRAM_LEVEL_USER=`echo $( telegramGetLevelAccessUser )`
	export WDS_TELEGRAM_LEVEL_USER
	
	
	# Verifica se tem um PIN ativo para este usuário que está acessando
	if cat "${WDS_DIR_TEMP}/${WDS_FILENAME_PIN}" | grep "${WDS_TELEGRAM_USER_CHAT_ID}" > /dev/null 2>&1; then
		WDS_TELEGRAM_ACCESS_PIN='YES'
		export WDS_TELEGRAM_ACCESS_PIN				
	fi
	
	# Verifica se o tipo de acesso é de cliente, se sim então as posições dos argumentos são diferentes
	if [ "${WDS_TELEGRAM_LEVEL_USER}" = 'CLIENTE' ] || [ "${WDS_TELEGRAM_ACCESS_PIN}" = 'YES' ]; then
		
		# Flag para validar se será necessário mudar a posição do argumento
		local update_position='TRUE'
		
		# Se estiver usando PIN, verifica se está sendo setado o nome do cliente
		if [ "${WDS_TELEGRAM_ACCESS_PIN}" = 'YES' ]; then
		
			# Mensagem do telegram para pegar o primeiro argumento da mensagem
			local args_telegram_cliente=`echo ${WDS_TELEGRAM_USER_MSG} | sed -e "s/\\\\\n/ /g"`

			# Recorta o argumento na posição escolhida
			local get_arg_cliente=`echo "${args_telegram_cliente}" | cut -d' ' -f1`
		
			# Criptografa o nome do cliente
			local client_name_script=$( encrypt "${get_arg_cliente}" )
			
			if [ -n "${client_name_script}" ]; then
			
				# Chamada de acesso pelo nome do cliente
				if cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_CLIENT}" | grep "${client_name_script}" > /dev/null 2>&1; then
					
					update_position='FALSE'
					
				fi
				
			fi
		
		fi
		
		
		# Verifica se é para mudar a posição dos argumentos
		if [ "${update_position}" = 'TRUE' ]; then
			
			# Vale somente para posições de argumentos maiores que 1
			if [ "${position}" -ne  1 ]; then
				position=$( expr ${position} - 1 )
			fi

		fi
			
		
	fi
	
	# Mensagem do telegram
	local args_telegram=`echo ${WDS_TELEGRAM_USER_MSG} | sed -e "s/\\\\\n/ /g"`
	
	# Recorta o argumento na posição escolhida
	local get_arg=`echo "${args_telegram}" | cut -d' ' -f${position}`
		
	# Necessário a conversão, pois o comando 'echo' interpreta esses comandos
	case "${get_arg}" in		
		'-n')
			get_arg='_n'
		;;
		
		'-e')
			get_arg='_e'
		;;
		
		'-E')
			get_arg='_E'
		;;
	esac

	echo "${get_arg}"
	
}

# telegramArgMenu
# Retorna o argumento do menu, função necessária porque retorna os valores em minúsculo
#	Args:
#		$1 - Posição do argumento
telegramArgMenu()
{
	local arg="$( telegramGetArgs $1 )"
	arg="${arg,,}"
	echo "${arg}"
}

# telegramArgMenu
# Retorna todos os argumentos do menu após um determinado menu
#	Args:
#		$1 - Posição inicial
telegramArgMenuAllNextPosition()
{
	local position=${1}
	local arq
	local menu=''
	
	local count_param=$( echo "${WDS_TELEGRAM_USER_MSG}" | grep -oi ' ' | wc -l)
		
	count_param=$( expr ${count_param} + 3 )
	
	for p in $(seq $position 50); do
	
		arg="$( telegramGetArgs $p )"
		
		# Necessário a conversão, pois o comando 'echo' interpreta esses comandos
		case "${arg}" in		
			'_n')
				arg='-n'
			;;
			
			'_e')
				arg='-e'
			;;
			
			'_E')
				arg='-E'
			;;
		esac
				
		# Se não retornar resultado então não existe mais parâmetros
		if [ ${count_param} -eq ${p} ]; then
			break;
		else
			menu+=" "
		fi
	
		menu+="${arg}"
	done
	
	echo "${menu}"
}


# Exemplo: /nomeCliente db-nomeConexaoBD scriptExecutar >>> db-nomeConexaoBD scriptExecutar

# Função responsável por responder as interações dos usuários via telegram
# Essa função somente é acessada via telegram e após o usuário ser autenticado pelo sistema
telegramInteract()
{
	writeLog "Execução direta de query db-"
		
	# Verifica o nível de privilégio do usuário
	telegramAccessLevel 'CLIENTE'
	
	# Gera um nome aleatório para este script
	name_new_script="tmp$( strRandom 5 )"
	name_new_script="${name_new_script,,}"
	
	# Primeiro registra o script que será executado
	telegramLibAdd 'sql' "name:${name_new_script} #> $( telegramArgMenuAllNextPosition 3 )"
	
	# Executa o script e não são repassados valores bind apena o nome da conexão com o banco de dados
	libExecute "${name_new_script}" "$( telegramArgMenu 2 )"		
}


# Executa um determinado script
libExecute()
{
	# Recebe o nome do arquivo que será apresentado
	local name_script="$1"
	
	# Armazena a lista de valores do bind variable
	local bind_variables_values="${2}"	
		
	writeLog "[LIB] Solicitação para executar o script: ${name_script}"
	writeLog "[LIB] Iniciando consulta ao script ${name_script}"
	
	show "- Solicitação para executar o script ${name_script}" 'debug'
	
	
	# Busca as informações do script, retorna um JSON
	local info_script="$( libInfoScript "${name_script}" )"
	
	
	# Verifica se o script foi encontrado
	if [ "${info_script}" = 'not_found' ]; then
		
		show "? Script não encontrado: ${name_script}"
		
		exit 1
		
	fi
	
	
	local info_type_execution="$(echo "${info_script}" | jq -r ".type_execution")"
	
	if [ "${info_type_execution}" = 'cmd' ]; then
		
		libExecuteCmd "${1}" "${bind_variables_values}"
		
		return 0
		
	fi
	
	if [ "${info_type_execution}" = 'sql' ]; then
		
		libExecuteSql "${1}" "${bind_variables_values}"
		
		return 0
		
	fi
	
}


# libInfoScript
# Retona as informações de um script
# Arg - $1 - Nome do Script
libInfoScript()
{
	# Recebe o nome do arquivo que será apresentado
	local name_script="$1"
	
	# Remove qualquer espaço em branco
	name_script=$( echo "${name_script}" | sed -e "s/ //g" )
	
	if [ -z "${name_script}" ]; then
	
		echo 'not_found'
		
		return 1
	fi
	
	# Criptografa o nome para saber se ele existe
	local name_script_cript=$( encrypt "name:${name_script}" )
			
	# Verifica se o nome do script existe
	if ! cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG}"|grep "${name_script_cript}" > /dev/null 2>&1; then
		
		writeLog "[LIB][ERRO] Script não encontrado: ${name_script}"
				
		echo 'not_found'
		
		return 1
		
	fi
	
	# Pega as informações do script
	local info_script=$( cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG}"|grep "${name_script_cript}" )
	
	# Descriptografa as informações do script
	info_script=$( decrypt "${info_script}" )
	
	
	# Inicializa a concatenação
	local concat_str
	concat_str='{'
	
	# Pecorre os campos de informação do script
	for info in ${info_script}; do
		
		info_param="$( echo ${info} | cut -d':' -f 1 )"
		info_value="$( echo ${info} | cut -d':' -f 2 )"
		
		# Armazena os valores em formato de json
		concat_str+="\"${info_param}\":\"${info_value}\","
		
	done
	
	concat_str+='}'
	
	info_script="${concat_str}"
	
	info_script=$(echo "$info_script" | sed "s/,}/}/g");
	
	echo "${info_script}"
	
	return 0
}



# libInfoFormat
# Retona as informações do arquivo de formatação
# Arg - $1 - Nome do Script
libInfoFormat()
{
	# Recebe o nome do arquivo que será apresentado
	local name_script="$1"
	
	# Remove qualquer espaço em branco
	name_script=$( echo "${name_script}" | sed -e "s/ //g" )
	
	# Adiona a palavra "format" no início do script
	name_script="format${name_script}"
	
	if [ -z "${name_script}" ]; then
	
		echo 'not_found'
		
		return 1
	fi
	
	# Criptografa o nome para saber se ele existe
	local name_script_cript=$( encrypt "name:${name_script}" )
			
	# Verifica se o nome do script existe
	if ! cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG}"|grep "${name_script_cript}" > /dev/null 2>&1; then
		
		writeLog "[LIB][ERRO] Script não encontrado: ${name_script}"
				
		echo 'not_found'
		
		return 1
		
	fi
	
	# Pega as informações do script
	local info_script=$( cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG}"|grep "${name_script_cript}" )
	
	# Descriptografa as informações do script
	info_script=$( decrypt "${info_script}" )
	
	
	# Inicializa a concatenação
	local concat_str
	concat_str='{'
	
	# Pecorre os campos de informação do script
	for info in ${info_script}; do
		
		info_param="$( echo ${info} | cut -d':' -f 1 )"
		info_value="$( echo ${info} | cut -d':' -f 2 )"
		
		# Armazena os valores em formato de json
		concat_str+="\"${info_param}\":\"${info_value}\","
		
	done
	
	concat_str+='}'
	
	info_script="${concat_str}"
	
	info_script=$(echo "$info_script" | sed "s/,}/}/g");
	
	echo "${info_script}"
	
	return 0
}


# libAddScript - Função chamada internamente
# Adiciona um novo script na biblioteca
# 	Args
#		$1 - Informações do Script
#		$2 - Se é para mostrar ao usuário a mensagem de cadastro do script na Lib YES/NO
libAddScript()
{	
	# Recebe um json com as informações do novo script
	local json_info_new_script="${1}"
	
	# Informa se é para mostrar ao usuário a mensagem de cadastro do script na Lib
	local show_message_add_script="${2}"
	
	# Usado para identificar comandos inválidos em scripts
	local command_invalid

	# Informações do novo script
	local name_new_script="$(echo "${json_info_new_script}" | jq -r ".name_new_script")"
	local path_new_script="$(echo "${json_info_new_script}" | jq -r ".path_new_script")"
	local type_execution="$(echo "${json_info_new_script}" | jq -r ".type_execution")"
	local group_new_script="$(echo "${json_info_new_script}" | jq -r ".group_new_script")"
	local pass_exec_new_script="$(echo "${json_info_new_script}" | jq -r ".pass_exec_new_script")"
	local graphic_x="$(echo "${json_info_new_script}" | jq -r ".graphic_x")"
	local graphic_y="$(echo "${json_info_new_script}" | jq -r ".graphic_y")"
	
	

	# Coloca o nome em minúsculo
	name_new_script="${name_new_script,,}"

	
	# Verifica se o nome do script é válido
	local is_alphaNumerics=$( isAlphaNumerics "${name_new_script}" )
	if [ "${is_alphaNumerics}" = 'false' ]; then
	
		writeLog "[LIB][ERRO] Nome escolhido para o scritp inválido: ${name_new_script}"
		show "?	Nome escolhido para o scritp inválido: { ${name_new_script} }"
		
		return 1
	
	fi
	
	# Criptografa o nome que será dado ao script para verificar se o nome já está sendo usado
	local name_new_script_cript=$( encrypt "name:${name_new_script}" )	
	
	# Verifica se o nome do script já está sendo usado
	if cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG}"|grep "${name_new_script_cript}" > /dev/null 2>&1; then
		
		writeLog "[LIB][ERRO] Nome do script já está sendo usado, nome usado: ${name_new_script}"
		
		show "? Nome do script já está sendo usado, nome: ${name_new_script}"
		
		return 1
		
	fi
	
	
	# Verifica se o script existe
	if ! ls "${path_new_script}" > /dev/null 2>&1; then
	
		writeLog "[LIB][ERRO] Script a ser anexado na biblioteca não encontrado"
		writeLog "	Caminho: ${path_new_script}"
		
		show "? Script de origem não encontrado, caminho: ${path_new_script}"
		
		return 1
	fi
	
	# Verifica se o grupo de acesso é válido
	local group_valid='false'
	
	# Coloca em maiúscula
	group_new_script="${group_new_script^^}"
	
	# Pecorre a lista de grupos para validar
	for group in ${WDS_TELEGRAM_GROUP_ACESS}; do
		
		if [ "${group}" = "${group_new_script}" ]; then
			group_valid='true'
			break
		fi		
		
	done
	
	if [ "$group_valid" = 'false' ]; then
	
		show "? Grupo informado não existe. Escolha um destes grupos: \nADMIN > Administra a aplicação \nANALISTA > Analista de sistemas ou desenvolvimento \nDBA > Privilégios de DBA \nCLIENTE > Clientes com acesso \nExemplo comando: nome_cliente user key create DBA"

		writeLog "[LIB][ERRRO] Grupo informado ${group_key}  não existe"
		writeLog "	- Escolha um destes groupos:"
		writeLog "	- ADMIN > Administra a aplicação"
		writeLog "	- ANALISTA > Analista de sistemas ou desenvolvimento"
		writeLog "	- DBA > Privilégios de DBA"
		writeLog "	- CLIENTE > Clientes com acesso"		
	
		return 1
	fi
	
	
	# Formata o aquivo de origem do telegram
	writeLog "[LIB] Formatando arquivo origem telegram"
	
	show "- Formatando arquivo origem telegram" 'debug'
	
	# Remove os caracteres especiais gerados pelo download do arquivo via telegram
	sed -i 's/\r//' "${path_new_script}"
	
	
	# Verifica se o tipo de execução é validada
	case "${type_execution}" in
		
		cmd)
			writeLog "[LIB] Tipo execução: Prompt de comando"
			show "- Tipo execução: Prompt de comando" 'debug'
		;;
		
		sql)
			writeLog "[LIB] Tipo execução: sqlplus"
			show "- Tipo execução do script anexado: sqlplus" 'debug'
		;;
		
		graf)
			writeLog "[LIB] Tipo execução: gráfico"
			show "- Tipo execução do script anexado: gráfico" 'debug'
		;;
		
		*)
			writeLog "[LIB] Tipo execução escolhido inválido"
			show "? Tipo execução escolhido inválido ${type_execution}" 'debug'
			exit 1
		;;
	esac

	# Para script do tipo cmd deve ser válidado se existe erro de sintaxe
	if [ "${type_execution}" = 'cmd' ]; then
		
		# Verifica se o script possui erro de sintaxe
		if ! bash -n "${path_new_script}" > /dev/null 2>&1; then
			
			local msg_erro="${WDS_DIR_TEMP}/msg_erro_$( strRandom 15 ).log"
			$( bash -n "${path_new_script}" > /dev/null 2>"${msg_erro}" )
			msg_erro=$( cat "${msg_erro}" )
			
			writeLog "[LIB][ERRO] Script original contém erro em sua sintaxe"
			
			writeLog "	- Erro: ${msg_erro}"
			
			show "? Script original contém erro em sua sintaxe.\nNo arquivo de log é apresentado o tipo de erro."
			
			# Apaga o arquivo com a mensagem de erro
			rm ${msg_erro} > /dev/null 2>&1
			
			return 1
			
		fi
		
		# Verifica se existe algum comando não permitido entre os comandos
		for command in ${WDS_COMMAND_BANNED_CMD}; do
			
			# Verifica se algum comando proibido em seu script
			command_invalid=`echo $(cat "${path_new_script}" | grep -iF "${command} "| wc -l )`
			
			# Verifica se algum comando inválido foi identificado
			if [ ${command_invalid} -gt 0  ]; then
				
				writeLog "[LIB][ERRO] Script possui comando proibido"
				writeLog "	- Comando encontrado: ${command}"
				
				show "? Script possui comando proibido. \nComando: ${command}"
				
				exit 1				
			fi
			
		done
		
	fi
	
	# Para script do tipo sql é adicionado os comandos do SQLPLUS
	if [ "${type_execution}" = 'sql' ]; then
	
		# Verifica se existe algum comando não permitido entre os comandos
		for command in ${WDS_COMMAND_BANNED_SQL}; do
			
			# Verifica se algum comando proibido em seu script
			command_invalid=`echo $(cat "${path_new_script}" | grep -iF "${command} "| wc -l )`
			
			# Verifica se algum comando inválido foi identificado
			if [ ${command_invalid} -gt 0  ]; then
				
				writeLog "[LIB][ERRO] Script possui comando proibido"
				writeLog "	- Comando encontrado: ${command}"
				
				show "? Script possui comando proibido. \nComando: ${command}"
				
				exit 1				
			fi
			
		done
	
	fi
	
	# Para script do tipo sql é adicionado os comandos do SQLPLUS
	#if [ "${type_execution}" = 'graf' ]; then
	#	
	#	writeLog "[LIB] Gerando arquivo de execução SQLPLUS"
	#	show '- Gerando arquivo de execução SQLPLUS' 'debug'
	#	
	#	local bind_sql_count=`echo $(cat "${path_new_script}" | grep -oh ":[a-z_0-9]*"| wc -l )`
	#	local bind_sql=`echo $(cat "${path_new_script}" | grep -oh ":[a-z_0-9]*" )`
	#	
	#	# ORA_HOME e TNS será definido na execução do script, onde deve ser informado do DBNAME a ser usado		
	#	
	#	local concat_str
	#	concat_str=''
	#	concat_str+="${graphic_x}"
	#	concat_str+='\n'
	#	concat_str+="${graphic_y}"
	#	concat_str+='\n'
	#	concat_str+=`echo $(cat "${path_new_script}")`
	#			
	#			
	#	# Gera um novo nome para o script
	#	local name_new_graf="$( strRandom 15 )"
	#	
	#	# O nome do gráfico de origem passa a ser o outro criado dinâmicamente
	#	path_new_script="${WDS_DIR_TEMP}/${name_new_graf}.txt"
	#			
	#	# Cria o arquivo
	#	concatWriteFile -n "${path_new_script}" "${concat_str}"
	#	
	#fi
	
	# Gera um novo nome para o script
	local name_fantasy_script="$( strRandom 15 )"
	
	
	# Se o nome do arquivo existir, então é gerado um novo nome que não existe
	until ! ls "${WDS_DIR_LIB_USER_ORIGINAL}/${name_fantasy_script}" 1> /dev/null 2>&1
	do
		name_fantasy_script="$( strRandom 15 )"
	done
		
	
	writeLog "[LIB][SUCCESS] Iniciando anexação do script na biblioteca"
	show "- Iniciando anexação do script na biblioteca" 'debug'
	
	
	# Realiza a cópia do arquivo
	if cp "${path_new_script}" "${WDS_DIR_LIB_USER_ORIGINAL}/${name_fantasy_script}" > /dev/null 2>&1; then
		
		writeLog "[LIB][SUCCESS] Cópia do script realizada com sucesso"
		
		show "- Cópia do script realizada com sucesso" 'debug'
		
	else
	
		writeLog "[LIB][ERRO] Erro ao copiar o script na biblioteca"
		
		show "? Erro ao copiar o script na biblioteca"
		
		return 1
	
	fi	
	
	# Se o tipo de script for de gráfico, então o script criado dinâmicamente é apagado
	#if [ "${type_execution}" = 'graf' ]; then
	#	rm "${path_new_script}"
	#fi	
	
	# Verifica se os scripts são iguais
	local valid_file_original=$( cat "${path_new_script}" | sha256sum )
	local valid_file_new=$( cat "${WDS_DIR_LIB_USER_ORIGINAL}/${name_fantasy_script}" | sha256sum )
	
	# Valida os arquivos
	if [ "${valid_file_original}" != "${valid_file_new}" ]; then
		
		writeLog "[LIB][ERRO] A cópia do arquivo não foi realizada de forma completa"
		
		show "? A cópia do arquivo não foi realizada de forma completa"
		
		return 1
	
	else
		
		writeLog "[LIB][SUCCESS] Cópia do arquivo realizada de forma completa"
		
		show "- Cópia do arquivo validada com sucesso" 'debug'
		
	fi
	
	# Usado temporariamente enquando não possui uso de Senha para execução
	pass_exec_new_script='undefined'
	# Verifica se uma senha de execução foi definida
	#if [ "${pass_exec_new_script}" = 'undefined' ]; then
	#	show "	- Script pode ser executado sem o uso senha" 'debug'
	#else
	#	show "	- Criptografando a senha que foi definida para permitir a execução do script" 'debug'
	#	pass_exec_new_script=$( echo "${pass_exec_new_script}" | md5sum | cut -d ' ' -f 1 ) 
	#fi

	##################################################
	# Para script do tipo sql deve ser criptogradado #
	##################################################
			
	writeLog "[LIB] Iniciando criptografia do script original anexado"
	show "- Iniciando criptografia do script original anexado" 'debug'
		
	# Pega a chave que será usada para criptografar
	local key_cript=`echo $( keyCript 'LIB' )`
	
	local file_original="${WDS_DIR_LIB_USER_ORIGINAL}/${name_fantasy_script}"
	
	# Criptografa o arquivo copiado
	local result_crypt=`echo $( encryptFile ${file_original} ${key_cript} )`
	
	# Verifica se o arquivo foi criptografado com sucesso
	if [ "${result_crypt}" = 'TRUE' ] ; then
		
		writeLog "[LIB][SUCCESS] Criptografia realizada com sucesso"		
		show "- Criptografia realizada com sucesso" 'debug'
		
	else
	
		writeLog "[LIB][ERRO] Erro ao criptografar o arquivo anexado"		
		show "- Erro ao criptografar o arquivo anexado #2"
		
		return 1
	fi

	writeLog "[LIB] Iniciando o registro e permissão de uso do script pela aplicação"
	show "- Iniciando o registro e permissão de uso do script pela aplicação" 'debug'
		
	# Data atual
	local dt=$( getDate '%d%m%Y_%Hh_%Mm_%Ss' )
	
	# Gera uma chave única para o script anexado
	local key_validation_script=$( cat "${WDS_DIR_LIB_USER_ORIGINAL}/${name_fantasy_script}" | sha256sum )
	
	# Selecionar a chave gerada
	key_validation_script=$( echo "${key_validation_script}" | cut -d' ' -f 1 )
	
	# Informa a origem do cadastro so script
	user_create="${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
	
	# Inicializa a concatenação para armazenar mais uma chave de autorização
	local concat_str
	concat_str=''
	concat_str+="name:${name_new_script}"
	concat_str+=' '
	concat_str+="name_fantasy:${name_fantasy_script}"
	concat_str+=' '
	concat_str+="file_script:${WDS_DIR_LIB_USER_ORIGINAL}/${name_fantasy_script}"
	concat_str+=' '
	concat_str+="type_execution:${type_execution}"
	concat_str+=' '
	concat_str+="user_create:${user_create}"
	concat_str+=' '
	concat_str+="key_validation_script:${key_validation_script}"
	concat_str+=' '
	concat_str+="key_cript:${key_cript}"
	concat_str+=' '
	concat_str+="group:${group_new_script}"
	concat_str+=' '
	#concat_str+="pass_exec:${pass_exec_new_script}"
	#concat_str+=' '
	concat_str+="data:${dt}"
	concat_str+=' '
		
	# Criptografa os dados da mensagem
	local script_cript="${concat_str}"
	
	# Criptografa o script
	script_cript=$( encrypt "${script_cript}" )	
	
	# Registra as informações do novo script no arquivo de catalogo do Lib
	if $( echo "${script_cript}" >> "${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG}" ); then
			
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG}"
		
		writeLog "[LIB][SUCCESS] Permissão de uso do script pela aplicação aprovado"
		writeLog "	+ Nome do script: ${name_new_script}"
	
		if [ "${show_message_add_script}" = 'YES' ]; then
			show "- Permissão de uso do script pela aplicação aprovado.\n	Nome do script: ${name_new_script}\n	Tipo de execução: ${type_execution}\n	Grupo de execução: ${group_new_script}\n"
		else
			show "- Permissão de uso do script pela aplicação aprovado.\n	Nome do script: ${name_new_script}\n	Tipo de execução: ${type_execution}\n	Grupo de execução: ${group_new_script}\n" 'debug'
		fi
		
	else
		
		writeLog "[ERRO] Erro ao permitir o uso do script pela aplicação"
		writeLog "	- Nome do script: ${client_new_name}"
		
		show "? Erro ao permitir o uso do script pela aplicação"
		
		return 1
		
	fi
}


# Executa um determinado script
libExecuteSql()
{
	# Pega o nível de acesso do telegram
	WDS_TELEGRAM_LEVEL_USER=`echo $( telegramGetLevelAccessUser )`
	
	# Recebe o nome do arquivo que será apresentado
	local name_script="$1"
	
	# Armazena a lista de valores do bind variable
	local bind_variables_values="${2}"
		
	# Busca as informações do script, retorna um JSON
	local info_script="$( libInfoScript "${name_script}" )"
	
		
	# Verifica se o script foi encontrado
	if [ "${info_script}" = 'not_found' ]; then
		
		show "? Script não encontrado: ${name_script}"
		
		exit 1
		
	fi
	
	# Verificando se o tipo de relatório solicitado é de Gráfico
	is_graphic_report
	
	local info_name_fantasy="$(echo "${info_script}" | jq -r ".name_fantasy")"
	local info_name="$(echo "${info_script}" | jq -r ".name")"
	local info_file_script="$(echo "${info_script}" | jq -r ".file_script")"
	local info_type_execution="$(echo "${info_script}" | jq -r ".type_execution")"
	local info_user_create="$(echo "${info_script}" | jq -r ".user_create")"
	local info_key_validation_script="$(echo "${info_script}" | jq -r ".key_validation_script")"
	local info_key_cript="$(echo "${info_script}" | jq -r ".key_cript")"
	local info_group="$(echo "${info_script}" | jq -r ".group")"
	local info_pass_exec="$(echo "${info_script}" | jq -r ".pass_exec")"
	local info_data="$(echo "${info_script}" | jq -r ".data")"
	local info_graphic_x="$(echo "${info_script}" | jq -r ".graphic_x")"
	
	
	# Informa se o usuário tem permissão para executar o script
	local permission_execute='TRUE'
	
	# Verifica se o usuário tem permissão de executar o script
	case "${info_group^^}" in
	
		ADMIN)
			
			if [ "${WDS_TELEGRAM_LEVEL_USER}" != "ADMIN" ]; then
				permission_execute='FALSE'
			fi
			
		;;
		
		DBA)
			
			if [ "${WDS_TELEGRAM_LEVEL_USER}" = "ANALISTA" ] || [ "${WDS_TELEGRAM_LEVEL_USER}" = "CLIENTE" ]; then
				permission_execute='FALSE'
			fi
			
		;;
		
		ANALISTA)
			
			if [ "${WDS_TELEGRAM_LEVEL_USER}" = "CLIENTE" ]; then
				permission_execute='FALSE'
			fi
			
		;;
		
	esac
	
	
	if [ "${permission_execute}" = "FALSE" ]; then
		
		writeLog "Usuário sem permissão para executar o script"
		writeLog "	- Permissão necessária: ${info_group}"
		writeLog "	- Permissão usuário: ${WDS_TELEGRAM_LEVEL_USER}"
		
		show "Você não tem permissão de executar esse script";
		
		exit 1
	fi
		
	#############
	# Verifica se o script precisa de senha para execução
	#############
	
	
	# Data atual
	local dt=$( getDate '%d%m%Y_%Hh_%Mm_%Ss' )
	
	# Gera uma chave única para o script de execução para validar o script
	local key_validation_script=$( cat "${info_file_script}" | sha256sum )
	key_validation_script="$( echo ${key_validation_script} | cut -d' ' -f 1 )"
	
	writeLog "[LIB][EXEC] Verificando se o script execução sofreu alteração"
	show "- Verificando se o script de execução sofreu alteração" 'debug'
	
	
	# Verifica se o arquivo foi alterado na origem
	if [ "${key_validation_script}" != "${info_key_validation_script}" ]; then
		
		writeLog "[LIB][EXEC][ERRO] - O arquivo de script { ${name_script} } foi alterado, desta forma ele está inválido"
		
		show "? O arquivo de script { ${name_script} } foi alterado, desta forma ele está inválido"
		
		exit 1
		
	fi
	
	
	# Inicio descriptografia do arquivo, para decriptografar, o arquivo criptogradado é copiado para o TEMP e lá é descriptografado e o criptogradado é apagado
	local file_execution_temp="${WDS_DIR_TEMP}/$( strRandom 4 ).sql"
	
	if ! cp "${info_file_script}" "${file_execution_temp}"; then
		
		writeLog "[LIB][ERRO] - Erro ao copiar o script para a pasta temporária"
		
		show "? Erro ao copiar o script para a pasta temporária"
		
		exit 1
		
	fi
	
	
	writeLog "[LIB] Iniciando a descriptografia do script"
	show "+ Iniciando a descriptografia do script" 'debug'
	
	# Pega a chave que será usada para criptografar
	local key_cript=`echo $( keyCript 'LIB' )`
	
	# Criptografa o arquivo de script		
	local result_decrypt=`echo $( decryptFile ${file_execution_temp} ${key_cript} )`
	
	# Verifica se o arquivo foi criptografado com sucesso
	if [ "${result_decrypt}" = 'TRUE' ] ; then
	
		writeLog "[LIB] Arquivo descriptografado com sucesso"
		show "+ Arquivo descriptografado com sucesso" 'debug'
	
	else
		
		writeLog "[LIB][ERRO] - Erro ao descriptografar o script"
		show "? Erro ao descriptografar o script"
		exit 1
		
	fi
	
	
	# Obrigatório, verifica se o nome da conexão foi informado
	if [ `echo "${bind_variables_values}" | grep "db-" | wc -l` -eq 0 ]; then
		
		writeLog "[LIB][EXEC][ERROR] - O nome da conexão com o banco de dados não foi informado"
		
		show "? Informe o nome de conexão com o banco de dados. \n\nExemplo:\n db-NAME_CONNECT"
		
		exit 1
	
	fi

	# Inicia a procura pelo nome da conexão a ser utilizada
	local name_connect_db
	
	# Armazena os demais parâmetros para ser utilizado posteriormente
	local list_bind_variables_values=''
	
	# Pecorre dentro dos parâmetros repassados
	for list_param in ${bind_variables_values}; do

		# Verifica se é o nome da conexão
		if [ `echo ${list_param} | grep "db-" | wc -l` -eq 1 ]; then
			
			name_connect_db="$( echo "${list_param}" | cut -d'-' -f 2 )"
			
			writeLog "[LIB][EXEC] Conexão de banco de dados usada para executar o script."
			writeLog "	Script: ${name_script}"
			writeLog "	Conexão: ${name_connect_db}"
			
		else
				
			# Verifica se não é um parâmetro composto
			if [ `echo ${list_param} | grep "_db_" | wc -l` -eq 0 ]; then
			
				# Cria lista de bind variable removendo o nome de conexão com o banco de dados
				list_bind_variables_values+="${list_param} "
				
			fi
			
		fi
		
	done
	
	# Adiciona a lista na variável primária, transforma os valores em um array
	bind_variables_values=( ${list_bind_variables_values} )

				
	# Busca as informações de conexão
	local info_connect=$( databaseGetInfoConnect "${name_connect_db}" )
	
	# Verifica se a conexão com o banco de dados foi encontrado
	if [ "${info_connect}" = 'not_found_connect' ]; then
		
		exit 1
		
	fi
	
	local db_name=''
	local db_sid=''
	local db_tns=''
	local db_home=''
	
	# Pecorre os valores a serem cadastrados
	for info in ${info_connect}; do
	
		param_name="$( echo "${info}" | cut -d':' -f 1 )"
		param_info="$( echo "${info}" | cut -d':' -f 2 )"
		
		# Adiciona nas variáveis corretas as informações
		case "${param_name}" in		
			'name')
				db_name="${param_info}"
			;;
			'sid')
				db_sid="${param_info}"
			;;
			'tns')
				db_tns="${param_info}"
			;;
			'home')
				db_home="${param_info}"
			;;
		esac
		
	done
			
	# Seleciona o usuário de conexão com o banco de dados
	if [[ ( "${WDS_TELEGRAM_LEVEL_USER}" == 'DBA' ) || ( "${WDS_TELEGRAM_LEVEL_USER}" == 'ADMIN' ) ]]; then

		# Tipo de usuário que irá realizar a conexão com o banco de dados
		local user_connect="${WDS_NAME_USER_ADMIN_DATABASE}"
		local password_connect=`echo $( databaseGetPassword "${WDS_NAME_USER_ADMIN_DATABASE}" )`
		
	else
		
		# Tipo de usuário que irá realizar a conexão com o banco de dados
		local user_connect="${WDS_NAME_USER_BASIC_DATABASE}"
		local password_connect=`echo $( databaseGetPassword "${WDS_NAME_USER_BASIC_DATABASE}" )`
		
	fi
	
	
	# Pega o conteúdo do arquivo e adiciona a uma variável
	local script_content=$( cat "${file_execution_temp}" )
	
	# Remove espaços em branco no começo e fim do arquivo
	script_content="$(echo -e "${script_content}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
	
	
	
	# Nome do arquivo temporário para execução interna do script
	local filename_temp="log_execute_${name_script}_$( strRandom 4 )"
		
	# Cria o arquivo com o SQL a ser executado
	local concat_str_sql
	concat_str_sql='spool '"${WDS_DIR_TEMP}"'/'"${filename_temp}"'_success.txt'
	concat_str_sql+='\n'
	
	concat_str_sql+='SET HEAD ON;'
	concat_str_sql+='\n'
	
	concat_str_sql+='SET FEED OFF;'
	concat_str_sql+='\n'
	
	concat_str_sql+='SET TERM OFF'
	concat_str_sql+='\n'
	
	## o comprimento da linha. Na maioria dos casos, o valor máximo para linesize é 32767 
	concat_str_sql+='SET LINESIZE 32767'
	concat_str_sql+='\n'
	
	## SET TRIMSPOOL ON caso contrário, todas as linhas no arquivo de spool serão preenchidas com espaços em branco até que o tamanho da linha seja atingido.
	concat_str_sql+='SET TRIMSPOOL ON'
	concat_str_sql+='\n'
	
	# SET TRIMOUT ON caso contrário, todas as linhas da saída serão preenchidas com espaços em branco até que o tamanho da linha seja atingido.
	concat_str_sql+='SET TRIMOUT ON'
	concat_str_sql+='\n'
	
	# SET WRAP OFFTrunca a linha, se for maior que LINESIZE. Isso não deve acontecer se o tamanho da linha for grande o suficiente.
	concat_str_sql+='SET WRAP ON'
	concat_str_sql+='\n'
	
	# SET TERMOUT OFFsuprime a impressão dos resultados na saída. As linhas ainda são gravadas no arquivo de spool. Isso pode acelerar muito o tempo de execução de uma declaração.
	concat_str_sql+='SET TERMOUT OFF'
	concat_str_sql+='\n'
	
	concat_str_sql+='SET VERIFY OFF'
	concat_str_sql+='\n'
	
	concat_str_sql+='SET SERVEROUTPUT ON'
	concat_str_sql+='\n'


	#
	#
	# INICIO - Verifica se existe algum arquivo de formatação pré-definido
	#
	#
	
	# Pega o nome do arquivo de formatação para validar se ele exite
	local name_file_format=$( echo "${name_script}" | sha256sum )
	
	# Seleciona o nome gerado
	name_file_format=$( echo "${name_file_format}" | cut -d' ' -f 1 )
	
	# Caminho do arquivo de formatação
	local path_name_file_format="${WDS_DIR_LIB_USER_ORIGINAL_FORMAT}/${name_file_format}"
	
	# Verifica se o arquivo de formatação existe
	if ls "${path_name_file_format}" > /dev/null 2>&1; then
		
		#
		# Se entrar o arquivo de formatação existe
		#
		
		
		# Busca as informações do arquivo de formatação, retorna um JSON
		local info_format="$( libInfoFormat "${name_script}" )"
		
			
		# Verifica se o script foi encontrado
		if [ "${info_format}" = 'not_found' ]; then
			
			show "? Arquivo de formatação não encontrado"
			
			exit 1
			
		fi
				
		local format_info_name_fantasy="$(echo "${info_format}" | jq -r ".name_fantasy")"
		local format_info_name="$(echo "${info_format}" | jq -r ".name")"
		local format_info_file_script="$(echo "${info_format}" | jq -r ".file_script")"
		local format_info_type_execution="$(echo "${info_format}" | jq -r ".type_execution")"
		local format_info_user_create="$(echo "${info_format}" | jq -r ".user_create")"
		local format_info_key_validation_script="$(echo "${info_format}" | jq -r ".key_validation_script")"
		local format_info_key_cript="$(echo "${info_format}" | jq -r ".key_cript")"
		local format_info_group="$(echo "${info_format}" | jq -r ".group")"
		local format_info_pass_exec="$(echo "${info_format}" | jq -r ".pass_exec")"
		local format_info_data="$(echo "${info_format}" | jq -r ".data")"
		
		
		
		# Gera uma chave única para o script de execução para validar o script
		local format_key_validation_script=$( cat "${format_info_file_script}" | sha256sum )
		format_key_validation_script="$( echo ${format_key_validation_script} | cut -d' ' -f 1 )"
		
		writeLog "[LIB][EXEC] Verificando se o arquivo de formatação sofreu alteração"
		show "- Verificando se o arquivo de formatação sofreu alteração" 'debug'
				
		# Verifica se o arquivo foi alterado na origem
		if [ "${format_key_validation_script}" != "${format_info_key_validation_script}" ]; then
			
			writeLog "[LIB][EXEC][ERRO] - O arquivo de formatação foi alterado, desta forma ele está inválido"
			
			show "? O arquivo de formatação foi alterado, desta forma ele está inválido"
			
			exit 1
			
		fi
		
		
		# Inicio descriptografia do arquivo, para decriptografar, o arquivo criptogradado é copiado para o TEMP e lá é descriptografado e o criptogradado é apagado
		local format_file_execution_temp="${WDS_DIR_TEMP}/$( strRandom 4 ).sql"
		
		if ! cp "${format_info_file_script}" "${format_file_execution_temp}"; then
			
			writeLog "[LIB][ERRO] - Erro ao copiar o arquivo de formatação para a pasta temporária"
			
			show "? Erro ao copiar o arquivo de formatação para a pasta temporária"
			
			exit 1
			
		fi
		
		
		writeLog "[LIB] Iniciando a descriptografia do arquivo de formatação"
		show "+ Iniciando a descriptografia do arquivo de formatação" 'debug'
		
		# Pega a chave que será usada para criptografar
		local format_key_cript=`echo $( keyCript 'LIB' )`
		
		# Criptografa o arquivo de script		
		local format_result_decrypt=`echo $( decryptFile ${format_file_execution_temp} ${format_key_cript} )`
		
		# Verifica se o arquivo foi criptografado com sucesso
		if [ "${format_result_decrypt}" = 'TRUE' ] ; then
		
			writeLog "[LIB] Arquivo de formatação descriptografado com sucesso"
			show "+ Arquivo de formatação descriptografado com sucesso" 'debug'
		
		else
			
			writeLog "[LIB][ERRO] - Erro ao descriptografar o arquivo de formatação"
			show "? Erro ao descriptografar o arquivo de formatação"
			exit 1
			
		fi
		
		
		# Pega o conteúdo do arquivo de formatação e adiciona a uma variável
		local format_content=$( cat "${format_file_execution_temp}" )
		
		
		
		
		#
		# Se chegar até aqui, então o arquivo de formatação é válido
		#
		
		
		
		# Pecorre cada linha do arquivo de formatação
		while read LINHA; do
					
			# Adiciona a formatação na consulta do usuário
			concat_str_sql+="${LINHA}"
			concat_str_sql+='\n'
		
		done < "${format_file_execution_temp}"
		
		# Apaga o arquivo temporário de formatação criado
		rm "${format_file_execution_temp}"
		
		
	else
	
		writeLog "Script não possui arquivo de formatação"
		
	fi
	
	
	#
	#
	# FIM - Verifica se existe algum arquivo de formatação pré-definido
	#
	#
	
	
	
	
	# --
	# --
	# Registra um FORMAT para cada coluna
		
	#	# Variáveis para listar as colunas
	#	local stmt_sql_upper list_columns name_column column_used count_column my_column arr_col delimiter
	#	
	#	# Transforma o conteúdo em maiúscula
	#	stmt_sql_upper=${script_content^^}
	#
	#	# Pega as colunas a serem usadas
	#	list_columns=$(echo "${stmt_sql_upper}" | grep -o -P '(?<=SELECT).*?(?=FROM)' | sed -n '1p')
	#	
	#	delimiter=","
	#	my_column=$list_columns$delimiter
	#	
	#	# Pecorre a lista de colunas para utilizar somente as corretas
	#	while [[ $my_column ]]; do
	#		
	#		name_column=( "${my_column%%"$delimiter"*}" );
	#		
	#		arr_col=(${name_column// / })
	#		count_column=${#arr_col[@]}
	#		column_used=$(echo $name_column | cut -d' ' -f${count_column})
	#		
	#		my_column=${my_column#*"$delimiter"};
	#		
	#		
	#		concat_str_sql+="COLUMN ${column_used} CLEAR"
	#		concat_str_sql+='\n'
	#		
	#		concat_str_sql+="COLUMN ${column_used} FORMAT A50"
	#		concat_str_sql+='\n'
	#		
	#		concat_str_sql+="COLUMN ${column_used} JUSTIFY LEFT"
	#		concat_str_sql+='\n'
	#		
	#		concat_str_sql+="COLUMN ${column_used} HEADING ${column_used}"
	#		concat_str_sql+='\n'
	#		
	#		concat_str_sql+="COLUMN ${column_used} truncated"
	#		concat_str_sql+='\n'
	#					
	#		writeLog ""
	#		writeLog "--------------"
	#		writeLog "COLUMN ${column_used} FORMAT A100"
	#		writeLog "--------------"
	#		writeLog ""
	#		
	#	done;
		
	# Fim registra um FORMAT para as colunas
	# --
	# --	
	
	
	
	
	# Verifica se existem bind variables
	local content_sql="$(cat "${file_execution_temp}")"
	content_sql="${content_sql^^}"
		
	# Pega somente os valores após o FROM
	local content_from=$(echo "${content_sql}" | grep -o -P '(?<=FROM).*?(?=;)' | sed -n '1p')
		
	local bind_sql_count=`echo $(echo "${content_from}" | grep -oh ":[A-Z_a-z_0-9]*"| wc -l )`
	
	# Verifica se foi encontrado bind variables
	if [ ${bind_sql_count} -gt 0  ]; then
		
		# Busca os nomes dos bind variables
		local bind_sql=`echo $(echo "${content_from}" | grep -oh ":[A-Z_a-z_0-9]*" )`
		
		# Verifica se a quantidade de bind variables são iguais a repassada por argumentos
		if [[ ( "${bind_variables_values}" == '' ) || ( ${bind_sql_count} -ne ${#bind_variables_values[@]} ) ]]; then
			
			writeLog "[LIB][ERRO] - Quantidade de bind variable está incorreta"
			writeLog "		Quantidade necessária: ${bind_sql_count}"
			writeLog "		Lista de variáveis: ${bind_sql}"
			
			show "? A quantidade de bind variable está incorreta.\n\nQuantidade necessária: ${bind_sql_count}.\n\nLista de ordem das variáveis: ${bind_sql}"
			exit 1
			
		fi
		
		# Contador para pegar o valor da variável que será usada
		local x_set_var=0
		local set_value_bind
		
		# Declara as variáveis que serão usadas
		for bind_declare in ${bind_sql}; do
			
			# Remove o sinal de dois pontos
			bind_declare=$(echo "${bind_declare}" | sed "s/://g")

			concat_str_sql+='\n'
			concat_str_sql+="variable ${bind_declare} varchar2(4000)"
			
			# Pega o valor da posição do bind
			set_value_bind="${bind_variables_values[x_set_var]}"
			x_set_var=$( expr ${x_set_var} + 1 )
			
			concat_str_sql+='\n'
			concat_str_sql+="exec :${bind_declare}:='${set_value_bind}'"
			
		done
				
		
	fi
		
	# Verifica se é relatório do tipo gráfico
	if [ "${WDS_IS_GRAPHIC_REPORT}" = "FALSE" ]; then
		
		concat_str_sql+='\n'
		concat_str_sql+="${script_content}"
		
	else
	
		# Escape, coloca duas aspas onde foi identificado uma aspa
		script_content_parser=$(echo "${script_content}" | sed "s/'/''/g")
		
		# Remove o ponto-e-virgula da query
		script_content_parser=$(echo "${script_content_parser}" | sed "s/;//g")
		
		
		concat_str_sql+='\n'
		concat_str_sql+='DECLARE'
		concat_str_sql+='\n'

			concat_str_sql+='v_SQL_STMT VARCHAR2(4000);'
			concat_str_sql+='\n'
			
			concat_str_sql+='v_IS_VALID VARCHAR2(1);'
			concat_str_sql+='\n'
			
			concat_str_sql+='v_COLUMN_X VARCHAR2(255);'
			concat_str_sql+='\n'
			
			concat_str_sql+='v_COLUMN_Y VARCHAR2(255);'
			concat_str_sql+='\n'
						
			concat_str_sql+="v_COLUMN_COUNT NUMBER;"
			concat_str_sql+='\n'
			
			
			
			concat_str_sql+='PROCEDURE PARSE_QUERY'
			concat_str_sql+='\n'
			
			concat_str_sql+='AS'
			concat_str_sql+='\n'
			
				concat_str_sql+='curid NUMBER;'
				concat_str_sql+='\n'
				
				concat_str_sql+='desctab DBMS_SQL.DESC_TAB3;'
				concat_str_sql+='\n'
				
				concat_str_sql+='colcnt NUMBER;'
				concat_str_sql+='\n'
								
				concat_str_sql+='sql_stmt VARCHAR2(4000);'
				concat_str_sql+='\n'
			
			concat_str_sql+='BEGIN'
			concat_str_sql+='\n'
			
				concat_str_sql+="sql_stmt:='"
					concat_str_sql+="${script_content_parser}"
				concat_str_sql+="';"
				
				concat_str_sql+='\n'
			
				# Inicia o processo de descrição da consulta
				concat_str_sql+='curid := SYS.DBMS_SQL.OPEN_CURSOR;'
				concat_str_sql+='\n'
				
				concat_str_sql+='SYS.DBMS_SQL.PARSE(curid, sql_stmt, SYS.DBMS_SQL.NATIVE);'
				concat_str_sql+='\n'
			 
				concat_str_sql+='SYS.DBMS_SQL.DESCRIBE_COLUMNS3(curid, colcnt, desctab);'
				concat_str_sql+='\n'
				
				# Registra a quantidade de COUNT dentro da variável glogal
				concat_str_sql+='v_COLUMN_COUNT := colcnt;'
				concat_str_sql+='\n'
				
				#Devem existir no mínímo duas colunas
				concat_str_sql+='IF colcnt < 2 THEN'
				concat_str_sql+='\n'
				
					concat_str_sql+="v_IS_VALID := 'N';"
					concat_str_sql+='\n'
				
				concat_str_sql+='ELSE'
				concat_str_sql+='\n'
				
					concat_str_sql+='v_COLUMN_X := desctab(1).col_name;'
					concat_str_sql+='\n'
					
					concat_str_sql+='v_COLUMN_Y := desctab(2).col_name;'
					concat_str_sql+='\n'
															
					concat_str_sql+="v_IS_VALID := 'Y';"
					concat_str_sql+='\n'
				
				concat_str_sql+='END IF;'
				concat_str_sql+='\n'
			 
				concat_str_sql+='DBMS_SQL.CLOSE_CURSOR(curid);'
				concat_str_sql+='\n'
				
			concat_str_sql+='END;'
			concat_str_sql+='\n'
			

			concat_str_sql+='PROCEDURE CREATE_GRAPHIC'
			concat_str_sql+='\n'
			concat_str_sql+='IS'
			concat_str_sql+='\n'
			
				concat_str_sql+='TYPE cur_typ IS REF CURSOR;'
				concat_str_sql+='\n'
				
				concat_str_sql+='I_cur cur_typ;'
				concat_str_sql+='\n'

				concat_str_sql+='col_x VARCHAR2(4000);'
				concat_str_sql+='\n'
				
				concat_str_sql+='col_y VARCHAR2(4000);'
				concat_str_sql+='\n'
				
				concat_str_sql+='col_title VARCHAR2(4000);'
								
				concat_str_sql+='\n'
								
			concat_str_sql+='BEGIN'
			concat_str_sql+='\n'
			
				
				concat_str_sql+="DBMS_OUTPUT.PUT_LINE( '<script>' );"
				concat_str_sql+='\n'
				
					concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'function SHOW_GRAPHIC(){' );"
					concat_str_sql+='\n'
						
						concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'var tabela = new google.visualization.DataTable();' );"
						concat_str_sql+='\n'
												
						concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'tabela.addColumn("
						
							concat_str_sql+='"string","'
							
							concat_str_sql+="' || "
							
							concat_str_sql+="v_COLUMN_X"
							
							concat_str_sql+=" || '"
							
							concat_str_sql+='");'
							
						
						concat_str_sql+="' );"
						
						concat_str_sql+='\n'
						
						
						concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'tabela.addColumn("
						
							concat_str_sql+='"number","'
							
							concat_str_sql+="' || "
							
							concat_str_sql+="v_COLUMN_Y"
							
							concat_str_sql+=" || '"
							
							concat_str_sql+='");'
							
						
						concat_str_sql+="' );"
						
						concat_str_sql+='\n'
						
						concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'tabela.addRows([' );"
						concat_str_sql+='\n'
						
						
						concat_str_sql+="OPEN I_cur FOR ${script_content}"
						concat_str_sql+='\n'
						
						concat_str_sql+='LOOP'
						concat_str_sql+='\n'
						
							concat_str_sql+='FETCH I_cur INTO col_x, col_y, col_title;'
							concat_str_sql+='\n'
							
							concat_str_sql+='EXIT WHEN I_cur%NOTFOUND;'
							concat_str_sql+='\n'							

							concat_str_sql+="DBMS_OUTPUT.PUT_LINE( '["
							
								concat_str_sql+='"'
								
								concat_str_sql+="'|| col_x ||'"
								
								concat_str_sql+='",'
								
								concat_str_sql+="'|| col_y ||'"
								
								concat_str_sql+='],'
								
							concat_str_sql+="');"
							
							
						concat_str_sql+='END LOOP;'
						concat_str_sql+='\n'
						
						concat_str_sql+='CLOSE I_cur;'
						concat_str_sql+='\n'
						
						
						concat_str_sql+="DBMS_OUTPUT.PUT_LINE( ']);' );"
							
						concat_str_sql+='\n'

						# Registra o nome do título
						concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'document.getElementById("
						concat_str_sql+='"title_wds").innerHTML="'
						
						concat_str_sql+="'||col_title||'"
						
						concat_str_sql+='"'
						
						concat_str_sql+=";' );"
						
						concat_str_sql+='\n'

						
						concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'var grafico = new google.visualization."						
				
							# Verifica se o gráfico pode ser em 3d, default vazio a variável option, quando usado essa variável será reescrita
							concat_str_is3d="DBMS_OUTPUT.PUT_LINE( 'var options = {};' );"
							
							# Verifica o tipo de gráfico escolhido
							case "${WDS_SELECTED_TYPE_GRAPHIC_REPORT}" in		
								'C')
									concat_str_sql+="ColumnChart"
								;;
								'B')
									concat_str_sql+="BarChart"
								;;
								'P')
								
									# Informa que esse gráfico pode ser 3d
									concat_str_is3d="DBMS_OUTPUT.PUT_LINE( 'var options = { is3D: true };' );"
								
									concat_str_sql+="PieChart"
								;;
								'SC')
									concat_str_sql+="ScatterChart"
								;;
								'A')
									concat_str_sql+="AreaChart"
								;;
								'ST')
									concat_str_sql+="SteppedAreaChart"
								;;
								'L')
									concat_str_sql+="LineChart"
								;;
							esac
							
							concat_str_sql+="(document.getElementById("
								
								concat_str_sql+='"MY_GRAPHIC"'
							
						concat_str_sql+="));' );"
						concat_str_sql+='\n'	

						
						# Caso existe 3d será informado aqui
						concat_str_sql+="${concat_str_is3d}"
						concat_str_sql+='\n'
						
						concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'grafico.draw(tabela, options);' );"
						concat_str_sql+='\n'
						
					concat_str_sql+="DBMS_OUTPUT.PUT_LINE( '}' );"
					concat_str_sql+='\n'
											
				
				concat_str_sql+="DBMS_OUTPUT.PUT_LINE( '</script>' );"
				concat_str_sql+='\n'
				
				concat_str_sql+="DBMS_OUTPUT.PUT_LINE( '<table id=""""customers"""">' );"
				concat_str_sql+='\n'				
					
					concat_str_sql+="DBMS_OUTPUT.PUT_LINE( '<tr><td><div id="
					
						concat_str_sql+='"MY_GRAPHIC"'
						
						concat_str_sql+="></div></td></tr>' );"
					
					concat_str_sql+='\n'
					
				concat_str_sql+="DBMS_OUTPUT.PUT_LINE( '<table>' );"
				concat_str_sql+='\n'
				
				
			concat_str_sql+='END;'
			concat_str_sql+='\n'
			
		concat_str_sql+='BEGIN'
		concat_str_sql+='\n'
		
			concat_str_sql+='PARSE_QUERY;'
			concat_str_sql+='\n'
			
			concat_str_sql+="IF v_IS_VALID = 'Y' THEN"
			concat_str_sql+='\n'
				
				concat_str_sql+='CREATE_GRAPHIC;'
				concat_str_sql+='\n'
			
			concat_str_sql+='ELSE'
			concat_str_sql+='\n'
			
				# Verifica se o erro gerado é por causa da quantidade de colunas da query
				concat_str_sql+='IF v_COLUMN_COUNT < 3 THEN'
				concat_str_sql+='\n'
				
					concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'Erro. A query deve possuir 3 colunas. <br /> ' );"
					concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'Primeira coluna {posição X do gráfico} <br /> ' );"
					concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'Segunda coluna {posição Y do gráfico} <br /> ' );"
					concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'Terceira coluna {título do relatório, tipo estático}' );"
					concat_str_sql+='\n'

				concat_str_sql+='ELSE'
				concat_str_sql+='\n'
				
					concat_str_sql+="DBMS_OUTPUT.PUT_LINE( 'Erro ao realizar o PARSE, valide a query.' );"
					concat_str_sql+='\n'
					
				
				concat_str_sql+='END IF;'
				concat_str_sql+='\n'
			
				
				
			concat_str_sql+='END IF;'
			concat_str_sql+='\n'
			
		concat_str_sql+='END;'
		concat_str_sql+='\n'

		concat_str_sql+='/'
		concat_str_sql+='\n'
		
	fi
	
	
	concat_str_sql+='\n'
	concat_str_sql+='spool off'
	concat_str_sql+='\n'
	concat_str_sql+='\n'
		
	# Cria o arquivo para execução do sql
	concatWriteFile -n "${file_execution_temp}" "${concat_str_sql}"
		
	
	# Inicializa a concatenação das informações para execução do script
	local concat_str
	concat_str='#!/bin/bash'
	concat_str+='\n'
	concat_str+='\n'
	
	concat_str+='export NLS_LANG=AMERICAN_AMERICA.UTF8'
	concat_str+='\n'
	
	concat_str+='start_script()'
	concat_str+='\n'
	concat_str+='{'
	concat_str+='\n'
	
	# Nome do arquivo de log de erro da execução do script
	concat_str+='local filename_temp='"${filename_temp}"
	concat_str+='\n'
	concat_str+='local filename_temp_success='"${WDS_DIR_TEMP}"'/${filename_temp}_success.txt'
	concat_str+='\n'
	concat_str+='local filename_temp_error='"${WDS_DIR_TEMP}"'/${filename_temp}_error.txt'
	concat_str+='\n'
	concat_str+='local filename_temp_execution='"${WDS_DIR_TEMP}"'/${filename_temp}_execution.txt'
	concat_str+='\n'
	
	# Variáveis com os argumentos do script para execução
	concat_str+='local name_script='"${name_script}"
	concat_str+='\n'
	concat_str+='local db_sid='"${db_sid}"
	concat_str+='\n'
	concat_str+='local db_tns='"${db_tns}"
	concat_str+='\n'
	concat_str+='local info_file_execution='"${file_execution_temp}"
	concat_str+='\n'
		
	concat_str+='local is_telegram=ok'
	concat_str+='\n'
	concat_str+='local telegram_chat='"${WDS_TELEGRAM_USER_CHAT_ID}"
	concat_str+='\n'
	concat_str+='local telegram_name="'"${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"'"'
	concat_str+='\n'
	
	concat_str+='local var_WDS_TITLE_GRAPHIC_REPORT="'"${WDS_TITLE_GRAPHIC_REPORT}"'"'
	concat_str+='\n'	
	
	# Inicializa o contador do tempo de execução do script
	concat_str+='start_cron_time_execution=`date +%s`'
	concat_str+='\n'
		
	
	concat_str+='\n'
	concat_str+='local CMD_SQL='"'${db_home}/bin/sqlplus -s '"
	concat_str+='\n'
	concat_str+='export ORACLE_HOME='"${db_home}"
	concat_str+='\n'
	concat_str+='export ORACLE_SID='"${db_sid}"
	concat_str+='\n'
	
	concat_str+='${CMD_SQL} '
	concat_str+="'${user_connect}/${password_connect}@${db_tns} '"
	concat_str+='<< EOF'
	concat_str+='\n'
	concat_str+='@${info_file_execution}'
	concat_str+='\n'
	concat_str+='exit;'
	concat_str+='\n'
	concat_str+='EOF'
	concat_str+='\n'
	concat_str+='if [ $? -eq 0 ]; then'
	concat_str+='\n'
	concat_str+='echo "SUCCESS_EXECUTION" > "${filename_temp_execution}"'
	concat_str+='\n'
	concat_str+='else'
	concat_str+='\n'
	concat_str+='echo "ERROR_EXECUTION" > "${filename_temp_execution}"'
	concat_str+='\n'
	concat_str+='fi'
	concat_str+='\n'
	
	
	# Apaga o arquivo de execução
	#concat_str+='rm "${info_file_execution}" > /dev/null 2>&1'
	concat_str+='\n'	
	concat_str+='\n'
	
	# Finaliza o contador do tempo de execução do script	
	concat_str+='end_cron_time_execution=`date +%s`'
	concat_str+='\n'
	
	
	# Total de segundos gastos na execução do script
	concat_str+='total_seconds_time_execution=`expr $end_cron_time_execution - $start_cron_time_execution`'
	concat_str+='\n'
	concat_str+='total_seconds_time_execution+=" sec"'
	concat_str+='\n'
	concat_str+='local json_result_exec_script'
	concat_str+='\n'
	concat_str+="json_result_exec_script='{'"
	concat_str+='\n'
	concat_str+='json_result_exec_script+="\"name_script\":\"${name_script}\","'
	concat_str+='\n'
	concat_str+='json_result_exec_script+="\"filename_temp_success\":\"${filename_temp_success}\","'
	concat_str+='\n'
	concat_str+='json_result_exec_script+="\"filename_temp_error\":\"${filename_temp_error}\","'
	concat_str+='\n'
	concat_str+='json_result_exec_script+="\"filename_temp_execution\":\"${filename_temp_execution}\","'	
	concat_str+='\n'
	concat_str+='json_result_exec_script+="\"type_script\":\"sql\","'
	concat_str+='\n'
	
	# Identificação do banco de dados usado
	concat_str+='json_result_exec_script+="\"db_sid\":\"${db_sid}\","'
	concat_str+='\n'
	concat_str+='json_result_exec_script+="\"db_tns\":\"${db_tns}\","'
	concat_str+='\n'
	
	concat_str+='json_result_exec_script+="\"total_seconds_time_execution\":\"${total_seconds_time_execution}\","'
	concat_str+='\n'
	concat_str+='json_result_exec_script+="\"is_telegram\":\"${is_telegram}\","'
	concat_str+='\n'
	concat_str+='json_result_exec_script+="\"telegram_chat\":\"${telegram_chat}\","'
	concat_str+='\n'
	
	concat_str+='json_result_exec_script+="\"telegram_name\":\"${telegram_name}\","'
	concat_str+='\n'
	
	
	if [ "${WDS_IS_GRAPHIC_REPORT}" = "FALSE" ]; then
		concat_str+='json_result_exec_script+="\"var_wds_is_graphic_report\":\"FALSE\""'
	else
		concat_str+='json_result_exec_script+="\"var_wds_title_graphic_report\":\"${var_WDS_TITLE_GRAPHIC_REPORT}\","'
		concat_str+='\n'
		
		concat_str+='json_result_exec_script+="\"var_wds_is_graphic_report\":\"TRUE\""'
	fi	
	
	concat_str+='\n'
	concat_str+="json_result_exec_script+='}'"
	concat_str+='\n'
	concat_str+="${WDS_FILENAME_SCRIPT_WDS}"' result_execute_lib "${json_result_exec_script}"'
	concat_str+='\n'
	concat_str+='}'
	concat_str+='\n'
	concat_str+='start_script &'
	concat_str+='\n'
	concat_str+="exit 0"
	concat_str+='\n'
	
	
		
	# Nome do arquivo que será criado para executar o script solicitado
	local filename_temp_execute="${WDS_DIR_TEMP}/execute_${name_script}_$( strRandom 4 ).sh"
	
	# Cria o arquivo para execução do script
	concatWriteFile -n "${filename_temp_execute}" "${concat_str}"
	
	# Transforma o script em executável
	chmod +x "${filename_temp_execute}"
	
	# Informa o inicio do script
	writeLog "[LIB][EXEC] Iniciando a execução do script >> ${name_script}"
	show "- Iniciando a execução do script >> ${name_script}" 'debug'
		
		
	# Executa o script
	"${filename_temp_execute}" &
	
	# Pega o PID de um script que foi executado em background
	local pid_exec=$!
		
	writeLog "[LIB][EXEC] Script iniciado no PID ${pid_exec}"
	
	show "- Script iniciado no PID ${pid_exec}" 'debug'
	
	rm "${filename_temp_execute}" > /dev/null 2>&1
			
}


# telegramLibAdd
# Registra um novo script na biblioteca via telegram
#	Args
#		$1 - Tipo de script que está sendo executado
#		$2 - Argumentos e informações do script para cadadastro
#		$3 - Se é para mostrar ao usuário a mensagem de cadastro do script na Lib YES/NO
telegramLibAdd()
{
	# Posição do script
	tracker_app 'telegramLibAdd'
	
	writeLog "Iniciando o cadastro do script"
	
	# Verificando se o tipo de relatório solicitado é de Gráfico
	is_graphic_report
	
	show "- Iniciando o cadastro do script.\nEsse processo pode demorar alguns minutos por causa da criptografia." 'debug'
	
	# Tipo de script que está sendo cadastrado
	local type_execution="${1}"
	
	# Informações sobre o script
	local info_script="${2}"
	
	# Informa se é para mostrar ao usuário a mensagem de cadastro do script na Lib
	local show_message_add_script="${3}"	
		
	local name_new_script=''
	local group_new_script=''
	
	# De onde veio o script que será cadastrado
	local origem_script
	
	# Caminho absoluto onde será armazenado o anexo
	local path_new_script="${WDS_DIR_TEMP}/wds_script_anexo_$( strRandom 15 ).txt"
	
	# Verifica a origem do Script de comando, pode ser atráves de um anexo ou via mensagem do chat
	# Via mensagem do chat o comando está logo após os caracteres #> 
	if [ `echo ${info_script} | grep "#>" | wc -l` -eq 0 ]; then
	
		# Via anexo
		origem_script='anexo'
		
		# Nome do arquivo que irá armazena o Script de execução
		local file_name_log_telegram="${WDS_DIR_TEMP}/telegram_download_$( strRandom 15 ).json"

		# Gera o arquivo JSON		
		curl "https://api.telegram.org/bot${WDS_TELEGRAM_TOKEN_BOT}/getFile?file_id=${WDS_TELEGRAM_DOCUMENT_FILE_ID}" > ${file_name_log_telegram}

		# Verifica se o comando anterior foi executado com sucesso
		if [ $? -ne 0 ]; then
			
			writeLog "[LIB][ERRO] Erro ao solicitar o anexo do script"
			
			show "? Erro ao solicitar o anexo do script"
		
			exit 1
			
		fi
		
		# Verifica se o telegram retornou uma resposta positiva
		if $( cat "$file_name_log_telegram" | jq -r ".ok" ) = true > /dev/null 2>&1; then
			
			# Anexo via telegram
			local file_path=$(cat "${file_name_log_telegram}" | jq -r ".result.file_path")			
			
			# Realiza o download do anexo
			wget -O "${path_new_script}" "https://api.telegram.org/file/bot${WDS_TELEGRAM_TOKEN_BOT}/${file_path}" > /dev/null 2>&1
			
			# Verifica se o comando anterior foi executado com sucesso
			if [ $? -ne 0 ]; then
				
				writeLog "[LIB][ERRO] Erro ao realizar o download do script"
				
				show "? Erro ao realizar o download do script"
			
				exit 1
				
			fi
		else
	
			writeLog "[LIB][ERRO] O arquivo com o script não foi anexado"
			
			show "? O arquivo com o script não foi anexado"
		
			exit 1
			
		fi
		
	else
	
		# Via chat
		origem_script='chat'
					
		# Armazena o comando que será executado
		local desc_command
		
		# Pega o comando a ser executado
		desc_command="$( echo "${info_script}" | cut -d'>' -f 2 )"
		info_script="$( echo "${info_script}" | cut -d'>' -f 1 )"
			
		# Remove espaço em branco no início do texto
		desc_command="$( echo "$desc_command" | sed 's/^ //g' )"
				
		# Se o tipo for de CMD então é adicionado o comando "#!/bin/bash" no início do arquivo
		if [ "${type_execution}" = 'cmd' ]; then		
		
			# Cria o arquivo com o comando a ser executado
			desc_command="#!/bin/bash\n${desc_command}"
			
		fi
				
		echo -e "${desc_command}" > "${path_new_script}"
		
	fi
	
	# Pecorre os valores a serem cadastrados
	for info in ${info_script}; do
	
		param_name="$( echo "${info}" | cut -d':' -f 1 )"
		param_info="$( echo "${info}" | cut -d':' -f 2 )"
		
		# Adiciona nas variáveis corretas as informações
		case "${param_name}" in		
			'name')
				name_new_script="${param_info}"
			;;
			'group')
				group_new_script="${param_info}"
			;;			
		esac
		
	done
	
	# Verifica se o nome do script foi informado manualmente
	if [ "${name_new_script}" = '' ]; then
		# Gera um nome aleatório
		name_new_script="tmp$( strRandom 5 )"
	fi
	
	
	# Verifica se o grupo de execução foi informado manualmente
	if [ "${group_new_script}" = '' ]; then
		# O grupo do usuário que está cadastrando se torna o grupo a ser usado
		group_new_script="${WDS_TELEGRAM_LEVEL_USER}"
	fi
	
	# Se o groupo for diferente de DBA e ADMIN, então algumas validações devem ser realizadas
	if [[ ( "${WDS_TELEGRAM_LEVEL_USER}" != 'DBA' ) && ( "${WDS_TELEGRAM_LEVEL_USER}" != 'ADMIN' ) ]]; then
		
		# Se o groupo for diferente de DBA e ADMIN, então só é aceito script do tipo sql
		if [ "${type_execution,,}" == 'cmd' ]; then
			
			writeLog "[LIB][ERRO] Você não possui autorização para registrar esse tipo de script"
			show '? Você não possui autorização para registrar esse tipo de script'
			exit 1
			
		fi
		
		# Se quem está registrando o script é diferente de um usuário do groupo DBA e ADMIN, então o usuário não pode registrar um script para um grupo acima do dele
		if [[ ( "${group_new_script,,}" == 'dba' ) || ( "${group_new_script,,}" == 'admin' ) ]]; then
			
			writeLog "[LIB][ERRO] Você não possui autorização para registrar esse script para esse grupo"
			show '? Você não possui autorização para registrar esse script para esse grupo'
			exit 1
			
		else
			group_new_script="${WDS_TELEGRAM_LEVEL_USER}"
		fi
	fi
	
	
	# Cria o JSON usado para cadastro do SCRIPT
	local list_arg
	list_arg='{'
	list_arg+="\"name_new_script\":\"${name_new_script}\","
	list_arg+="\"path_new_script\":\"${path_new_script}\","
	list_arg+="\"type_execution\":\"${type_execution}\","
	list_arg+="\"group_new_script\":\"${group_new_script}\","
	list_arg+="\"pass_exec_new_script\":\"${pass_exec_new_script}\","
	list_arg+="\"graphic_x\":\"${graphic_x}\","
	list_arg+="\"graphic_y\":\"${graphic_y}\""	
	list_arg+='}'
	
	
	# Chama a função que registra o script
	libAddScript "${list_arg}" "${show_message_add_script}"
			
	if rm "${path_new_script}" > /dev/null 2>&1; then
		
		writeLog "[LIB][SUCCESS] Arquivo de download apagado"
		
		show "Arquivo de download apagado" 'debug'
		
	else
		
		writeLog "[LIB][ERRO] Erro ao apagar o arquivo de download"
		
		show "	? Erro ao apagar o arquivo de download" 'debug'
		
		exit 1
	
	fi
	
}


# Retorna o password de conxão com o banco de dados
databaseGetPassword()
{
	# Posição do script
	tracker_app 'databaseGetPassword'	
	
	# Tipo de usuário que será alterado, WDS_ADMIN ou WDS_BASIC
	local type_user="${1}"
	
	# Arquivo que será alterado
	local file_type_user="${WDS_DIR_CONFIG}/${WDS_DB_USER_BASIC_PASSWORD}"
		
	# Verifica se está alterando do usuário admin
	if [ "${type_user}" == "${WDS_NAME_USER_ADMIN_DATABASE}" ]; then
		file_type_user="${WDS_DIR_CONFIG}/${WDS_DB_USER_ADMIN_PASSWORD}"
	fi
	
	# Verifica se o arquivo de senha é válido
	is_valid=`echo $( verifyKeyValidation "${file_type_user}" )`
	if [ "${is_valid}" = false ]; then

		writeLog "[DB][ERRO] Arquivo contendo a senha do usuário ${type_user} foi alterado e agora é considerado inválidado"
		writeLog "	- Reset o password"

		show "? Arquivo contendo a senha do usuário ${type_user} foi alterado e agora é considerado inválidado.\n - Reset o password."
					
		echo 'NOT_FOUND'
		
		return 1
	fi
	
	local password_connect=$( cat "${file_type_user}" )
	password_connect=`echo $( decrypt "${password_connect}" )`
	
	echo "${password_connect}"
	
}


# Busca as informações de uma determinada conexão
databaseGetInfoConnect()
{
	# Posição do script
	tracker_app 'databaseGetInfoConnect'
	
	local db_get_connect="${1,,}"
	
	local filename_temp="${WDS_DIR_TEMP}/${WDS_FILENAME_DATABASE_INFO_CONNECT}.tmp"
	
	# Criptografa o nome da conexão
	local db_get_connect_cript=$( encrypt "name:${db_get_connect}" )
		
	# Verifica se a conexão com o banco de dados existe
	if [ $( cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_DATABASE_INFO_CONNECT}" | grep "${db_get_connect_cript}" | wc -l ) -eq 0 ]; then
	
		writeLog "[DATABASE] Conexão com banco de dados não encontrado"
		writeLog "	- Conexão: ${db_get_connect}"
		
		show "Conexão com banco de dados não encontrado.\n\n Nome conexão: ${db_get_connect}"
		
		echo 'not_found_connect'
		
		return 1
	fi
	
	local info_connect=$( cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_DATABASE_INFO_CONNECT}" | grep "${db_get_connect_cript}" )
	info_connect=`echo $( decrypt "${info_connect}" )`
	
	echo "${info_connect}"
	
	return 0
		
}


# Resposta do Bot para uma chamada particular
telegramResponseChat()
{
	# Posição do script
	tracker_app 'telegramResponseChat'
	
	local chat_id=${WDS_TELEGRAM_USER_CHAT_ID}
	local response="${1}"
	
	# Se a resposta for redirecionada para todos os clientes, então é adicionado no começo da mensagem o nome do cliente
	if [ "${WDS_TELEGRAM_TYPE_CALL}" = 'ALL' ] || [ "${WDS_TELEGRAM_ACCESS_PIN}" = 'YES' ]; then
		local name_client="$( getNameClient )"
		response="Cliente: ${name_client} \n\n${response}"
	fi
	
	# Formata o resultado
	response=`echo "${response}" | sed -e "s/ /%20/g"`
	response=`echo "${response}" | sed -e "s/\\\\\n/%0A/g"`
	
	
	# Envia a resposta
	if ! `curl "${WDS_TELEGRAM_URL_API}${WDS_TELEGRAM_TOKEN_BOT}/sendMessage?chat_id=${chat_id}&parse_mode=HTML&reply_to_message_id=${WDS_TELEGRAM_USER_MSG_ID}&text=${response}"` > /dev/null 2>&1; then
	
		writeLog "[SUCCESS] Mensagem enviada com sucesso"
		
		status_response='SUCCESS'
		
		# Ativa a interação do usuário com o telegram
		telegramActiveInteraction
		
	else
	
		writeLog "[ERRO] Erro ao enviar a mensagem de resposta"
		
		status_response='ERRO'
		
	fi
	
	
	# Inicializa a concatenação da mensagem de resposta enviada para o usuário
	local concat_str
	concat_str='---------------'
	concat_str+='\n'
	concat_str+=$( getDate '%d/%m/%Y_%H:%M:%S' )
	concat_str+='\n'
	concat_str+='Mensagem Origem'
	concat_str+='\n'
	concat_str+="Usuário: ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
	concat_str+='\n'
	concat_str+="Chat id: ${WDS_TELEGRAM_USER_CHAT_ID}"
	concat_str+='\n'
	concat_str+="Mensagem id: ${WDS_TELEGRAM_USER_MSG_ID}"
	concat_str+='\n'
	concat_str+=' --- '
	concat_str+='\n'
	concat_str+='Mensagem Resposta'
	concat_str+='\n'
	concat_str+="${1}"
	concat_str+='\n'
	concat_str+='---------------'
	concat_str+='\n'
	concat_str+=''
	concat_str+='\n'
	
	
	# Criptografa os dados da mensagem
	local message_response=''
	message_response=$( encrypt "${concat_str}" )
	
	
	# Armazena a mensagem de resposta no arquivo
	concatWriteFile "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE}" "${message_response}"
	
	# Cria uma chave de validação para o arquivo de configuração
	createValidationKey "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE}"
	
}

# Envia pelo telegram ou apresenta na tela as infomações de um documento
telegramSendFile()
{
	# Posição do script
	tracker_app 'telegramSendFile'
	
	# Endereço do documento que será anexado
	local response="${1}"
	
	# Mensagem para enviar junto ao anexo
	local caption="${2}"
		
	# Formata o resultado
	#caption=`echo ${caption} | sed -e "s/ /%20/g"`
	#caption=`echo ${caption} | sed -e "s/\\\\\n/%0A/g"`
	
	
	# Se a resposta for redirecionada para todos os clientes, então é adicionado no começo da mensagem o nome do cliente
	if [ "${WDS_TELEGRAM_TYPE_CALL}" = 'ALL' ] || [ "${WDS_TELEGRAM_ACCESS_PIN}" = 'YES' ]; then
		local name_client="$( getNameClient )"
		caption="Cliente: ${name_client} / ${caption}"
	fi
	
		
	# Envia a resposta
	if ! `curl -v -F "chat_id=${WDS_TELEGRAM_USER_CHAT_ID}" -F document="@${response}" -F caption="${caption}" "${WDS_TELEGRAM_URL_API}${WDS_TELEGRAM_TOKEN_BOT}/sendDocument?reply_to_message_id=${WDS_TELEGRAM_USER_MSG_ID}"` > /dev/null 2>&1; then
	
		writeLog "[SUCCESS] Arquivo enviado com sucesso"
		
		# Ativa a interação do usuário com o telegram
		telegramActiveInteraction
		
	else
	
		writeLog "[ERRO] Erro ao enviar a mensagem de resposta"
					
	fi
	
	# Exclui o arquivo temporário
	writeLog "Apagando arquivo com as informações dos usuários"	
	if ! rm "${response}" > /dev/null 2>&1; then
		
		writeLog "[ERRO] O arquivo temporário ${response} não foi excluído"
		
	fi	
	
	
	# Inicializa a concatenação da mensagem de resposta enviada para o usuário
	local concat_str
	concat_str+='---------------'
	concat_str+='\n'
	concat_str+=$( getDate '%d/%m/%Y_%H:%M:%S' )
	concat_str+='\n'
	concat_str+='Mensagem Origem'
	concat_str+='\n'
	concat_str+="Usuário: ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
	concat_str+='\n'
	concat_str+="Chat id: ${WDS_TELEGRAM_USER_CHAT_ID}"
	concat_str+='\n'
	concat_str+="Mensagem id: ${WDS_TELEGRAM_USER_MSG_ID}"
	concat_str+='\n'
	concat_str+=' --- '
	concat_str+='\n'
	concat_str+='Mensagem Resposta'
	concat_str+='\n'
	concat_str+="Envio do arquivo ${response}"
	concat_str+='\n'
	concat_str+='---------------'
	concat_str+='\n'
	concat_str+=''
	concat_str+='\n'
	
	# Criptografa os dados da mensagem
	local message_response="${concat_str}"
	message_response=$( encrypt "${message_response}" )
	
	# Armazena a mensagem de resposta no arquivo
	concatWriteFile "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE}" "${message_response}"
	
	# Cria uma chave de validação para o arquivo de configuração
	createValidationKey "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE}"		
}


telegramActiveInteraction()
{
	# Ativa e zera o valor da interação com o usuário, diminuindo assim o tempo de resposta
	echo '0' > "${WDS_DIR_TEMP}/${WDS_TELEGRAM_INTERACAO_ATIVA}"
	
	writeLog "Ativando o sistema de interação com o usuário, diminuindo assim o tempo das próximas respostas"
}

# Função que informa se está sendo excutado um comando com o debug ativado
is_debug()
{
# Mensagem do telegram
	local args_telegram_original=`echo ${WDS_TELEGRAM_USER_MSG} | sed -e "s/\\\\\n/ /g"`
	local args_telegram_update=`echo ${args_telegram_original} | sed -e "s/-debug//g"`
	
	# Se as variáveis forem diferentes, então é para ativar o debug
	if [ "${args_telegram_original}" != "${args_telegram_update}" ]; then
		
		WDS_IS_DEBUG='TRUE'
		
		# Remove o debug da consulta
		WDS_TELEGRAM_USER_MSG="${args_telegram_update}"
	fi	
}


# Carrega as variáveis globais do ambiente
loadVariables()
{
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Daemon -------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	
		#- Nome do arquivo responsável por inicializar o DAEMON
		WDS_NAME_DAEMON='wds_skill_tools_d'
		
		# Nome do arquivo usado como flag para realizar a parada do processo de background
		WDS_FILENAME_STOPED_DAEMON='stoped_wds_skill_tools_d.stop'
		
		# Arquivo que armazena os pedidos de PIN
		WDS_FILENAME_PIN='wds_pin.tmp'
	
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Fixas Do Telegram --------------------------------------------------
	#---------------------------------------------------------------------------------------------
	
		#- Identificação do usuário ADMIN da aplicação
		WDS_TELEGRAM_USER_MASTER=866834875

		# Token de acesso ao Bot
		#WDS_TELEGRAM_TOKEN_BOT='851364578:AAHQ-N0Ax5c-_uiFlCWU2cM4sDE178B06zU'
		WDS_TELEGRAM_TOKEN_BOT='1457383349:AAGEkFE_TI26-mGmdgCXvMYLKdmkEn9SSe4'
		
		
		# Nome do arquivo usado como log de chamadas feitas pelo telegram
		WDS_TELEGRAM_FILENAME_LOG='telegram_call.log'
		
		# Se esse arquivo existir quer dizer que existe uma interação ativa com este cliente, reduzindo o tempo de resposta
		WDS_TELEGRAM_INTERACAO_ATIVA='telegram_active_interaction.tmp'
		
		# Lista os grupos de acesso dos usuários do telegram
		WDS_TELEGRAM_GROUP_ACESS='ADMIN ANALISTA DBA CLIENTE'
		
		# Informa o nível de acesso do usuário
		WDS_TELEGRAM_LEVEL_USER='NULL'
		
		# Verifica se o tipo de chamada foi para todas as aplicações instaladas
		WDS_TELEGRAM_TYPE_CALL='ALONE'
		
		# Informa se o acesso que está sendo realizado é via PIN
		WDS_TELEGRAM_ACCESS_PIN='NO'
		
		# Informa a URL da API do Telegram
		WDS_TELEGRAM_URL_API='https://api.telegram.org/bot'

	
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Variáveis com informações do telegram que está interagindo com a aplicação ----------
	#---------------------------------------------------------------------------------------------
	
		WDS_TELEGRAM_ADMIN_CHAT_ID=''
		WDS_TELEGRAM_USER_CHAT_ID=''
		WDS_TELEGRAM_USER_FIRST_NAME=''
		WDS_TELEGRAM_USER_LAST_NAME=''
		WDS_TELEGRAM_USER_MSG_ID=''
		WDS_TELEGRAM_USER_MSG=''
	
		# Mensagens com Anexo
		WDS_TELEGRAM_DOCUMENT_FILE_NAME=''
		WDS_TELEGRAM_DOCUMENT_MIME_TYPE=''
		WDS_TELEGRAM_DOCUMENT_FILE_ID=''
		WDS_TELEGRAM_DOCUMENT_FILE_SIZE=''
			
	
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Fixas --------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
		
		# Nome do usuário com permissão para executar o script
		WDS_NAME_USER_LINUX='wds_u'
		
		# Nome do script válido
		WDS_FILENAME_SCRIPT_WDS='wdsSkillToolsV1'
		
		# Nome do arquivo que registra a instalação
		WDS_FILENAME_INSTALL_APP='wdsSkillToolsV1_install.cfg'
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar o cliente
		WDS_FILENAME_LICENSE_APP='wds_license.cfg'
		
		#- Nome do manual nível ADMIN
		WDS_FILENAME_MANUAL_ADMIN='wds_manual_admin'
		
		#- Nome do manual nível DBA
		WDS_FILENAME_MANUAL_DBA='wds_manual_dba'
		
		#- Nome do manual nível ANALISTA
		WDS_FILENAME_MANUAL_STARTUP='wds_manual_analista'
		
		#- Nome do manual nível CLIENTE
		WDS_FILENAME_MANUAL_CLIENTE='wds_manual_cliente'

		#- Nome do arquivo principal de Log
		WDS_LOG_MAIN='wds_alert.log'
		
		#- Nome do arquivo de Log de execuções do daemon
		WDS_LOG_DAEMON='wds_daemon.log'

		# Nome do arquivo usado para armazenar os logs gerados pela cron
		WDS_FILENAME_CRON_LOG='wds_cron.log'
		
		#- Nome do arquivo onde armazenas os ID dos processos iniciados
		WDS_LOG_PID='wds_process_id.log'
		
		# Nome do arquivo onde armazena as mensagens do status de execução do daemon
		WDS_LOG_LIFE_DAEMON='wds_life_daemon.log'
		
		# Nome do usuário ADMIN de conexão com o banco de dados
		WDS_NAME_USER_ADMIN_DATABASE='WDS_ADMIN'
		
		# Nome do usuário BASIC de conexão com o banco de dados
		WDS_NAME_USER_BASIC_DATABASE='WDS_BASIC'
		
		# Comandos inválidos para script de CMD
		WDS_COMMAND_BANNED_CMD='su shutdown rm'
		
		# Comandos inválidos para script de SQL
		WDS_COMMAND_BANNED_SQL='drop delete truncate !'
		
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Fixas de Diretórios da Aplicação -----------------------------------
	#---------------------------------------------------------------------------------------------
	
		#- Caminho diretório atual
		WDS_DIR_ORIGEM="${WDS_APP_DIRNAME}"

		#- Caminho diretório onde serão armazenados todos os arquivos de processo
		WDS_DIR_PROC=${WDS_DIR_ORIGEM}'/proc_wds'
		
		#- Caminho diretório onde serão armazenados todos os aquivos de manual de uso
		WDS_DIR_MANUAL=${WDS_DIR_PROC}'/manual'

		#- Diretório principal para armazenar arquivos distintos
		WDS_DIR_TEMP=${WDS_DIR_PROC}'/temp'

		#- Diretório para armazenar os arquivos de log
		WDS_DIR_LOG=${WDS_DIR_PROC}'/log'

		#- Diretório para armazenar as configurações da aplicação
		WDS_DIR_CONFIG=${WDS_DIR_PROC}'/config'
		
		#- Diretório para armazenar as chaves da aplicação
		WDS_DIR_KEYS=${WDS_DIR_PROC}'/keys'
		
		#- Diretório para armazenar os scripts internos e externos
		WDS_DIR_LIB=${WDS_DIR_PROC}'/lib'
		
		#- Diretório para armazenar os scripts anexados pelos usuários
		WDS_DIR_LIB_USER=${WDS_DIR_LIB}'/user'
		
		#- Diretório para armazenar os scripts originais gravados
		WDS_DIR_LIB_USER_ORIGINAL=${WDS_DIR_LIB_USER}'/original'
		
		#- Diretório para armazenar as formatações dos scripts SQL
		WDS_DIR_LIB_USER_ORIGINAL_FORMAT=${WDS_DIR_LIB_USER}'/original/format'
		
		# Lista de todos os diretórios que serão criados
		WDS_DIR_LIST="${WDS_DIR_PROC} ${WDS_DIR_LOG} ${WDS_DIR_TEMP} ${WDS_DIR_CONFIG} ${WDS_DIR_KEYS} ${WDS_DIR_LIB} ${WDS_DIR_LIB_USER} ${WDS_DIR_LIB_USER_ORIGINAL} ${WDS_DIR_LIB_USER_ORIGINAL_FORMAT} ${WDS_DIR_MANUAL}"
		
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis de Uso Global ------------------------------------------------------
	#---------------------------------------------------------------------------------------------
		
		# Variável para informar se o comando é para ser excutado com o debug ativado
		WDS_IS_DEBUG='FALSE'
		
		# Variável para informar se é para retornar o relatório no modelo de gráfico
		WDS_IS_GRAPHIC_REPORT='FALSE'
		
		# Variável usada para informar os tipo de gráficos válidos / { COLUMN C }  { BAR B } { PIE P } { Scatter SC } { Area A } { SteppedArea ST } { Line L }
		WDS_VALID_TYPE_GRAPHIC_REPORT='C B P SC A ST L'
		
		# Variável usado para informar o tipo de gráfico escolhido, caso WDS_IS_GRAPHIC_REPORT for verdadeiro
		WDS_SELECTED_TYPE_GRAPHIC_REPORT=''
		
		# Variável usado para informar o título a ser usado no gráfico
		WDS_TITLE_GRAPHIC_REPORT=''
		
		# Origem do acesso a essa aplicação, até o momento apenas LOCAL / TELEGRAM
		WDS_ORIGEM_ACCESS='LOCAL'
		
		# Informa a posição do script naquele momento
		WDS_TRACKER_APP='loadVariables'
		
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Nome dos Arquivos de Configuração ----------------------------------
	#---------------------------------------------------------------------------------------------
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar o cliente
		WDS_FILENAME_NAME_CLIENT='wds_name_client.cfg'
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar o cliente
		WDS_FILENAME_NAME_SYS_USER='wds_name_sys_user.cfg'
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar os DBAs
		WDS_FILENAME_NAME_DBA='wds_name_dba.cfg'
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar o DBA de plantão
		WDS_FILENAME_NAME_DBA_PLANTAO='wds_name_dba_plantao.cfg'
		
		#- Arquivo contendo o password do usuário admin do banco de dados
		WDS_DB_USER_ADMIN_PASSWORD='wds_db_password_user_admin.cfg'
		
		#- Arquivo contendo o password do usuário básico do banco de dados
		WDS_DB_USER_BASIC_PASSWORD='wds_db_password_user_basic.cfg'
		
		# Nome do arquivo usado para armazenar os dados dos usuários cadastrados
		WDS_TELEGRAM_FILENAME_USERS='users_telegram.cfg'
		
		# Nome do arquivo usado para armazenar os dados dos usuários cadastrados
		WDS_FILENAME_USERS_KEY_ACCESS='users_key_access_telegram.cfg'
		
		# Nome do arquivo usado para armazenar as configurações dos scripts anexados na biblioteca
		WDS_FILENAME_LIB_CONFIG='wds_lib.cfg'
		
		# Nome do arquivo usado para armazenar os nomes das bases de dados
		WDS_FILENAME_DATABASE_INFO_CONNECT='wds_database_connect.cfg'
		
		# Nome do arquivo usado para armazenar os dados dos usuários cadastrados
		WDS_TELEGRAM_FILENAME_MSG_RESPONSE='message_response_telegram.cfg'
		
		#- Armazena a lista de arquivos de configuração
		WDS_LIST_FILENAME_CFG="Cliente:${WDS_FILENAME_NAME_CLIENT} SysUser:${WDS_FILENAME_NAME_SYS_USER} Usuarios_telegram:${WDS_TELEGRAM_FILENAME_USERS} Chaves_acessos_telegram:${WDS_FILENAME_USERS_KEY_ACCESS} Message_response_telegram:${WDS_TELEGRAM_FILENAME_MSG_RESPONSE} Lib_config:${WDS_FILENAME_LIB_CONFIG} Database_Connect:${WDS_FILENAME_DATABASE_INFO_CONNECT} DBA_Users:${WDS_FILENAME_NAME_DBA} DBA_Plantao:${WDS_FILENAME_NAME_DBA_PLANTAO}"
}



# Envia uma notificação para o usuário master
telegramNotifyUserMaster()
{
	local chat_id=866834875

	local caption="${1}"
	
	local path="$( pwd )"
	
	local anexo_config="${path}/$( strRandom 15 ).txt"
	
	local inf_uname=`uname -a`
	local inf_lspci=`lspci`
	local inf_ifconfig=`ifconfig`
	
	
	# Adiciona as informações em um arquivo
	echo -e "Hostname: ${HOSTNAME}" > "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	echo -e "Informações do usuário ( uname -a )" >> "${anexo_config}"
	echo -e "${inf_uname}" >> "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	echo -e "" >> "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	echo -e "Informações de hardware ( lspci )" >> "${anexo_config}"
	echo -e "${inf_lspci}" >> "${anexo_config}"
	
	echo -e "" >> "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	echo -e "Informações de network (ifconfig)" >> "${anexo_config}"
	echo -e "${inf_ifconfig}" >> "${anexo_config}"
	
	echo -e "" >> "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	
	local new_installation="${caption} / Informações do server: ${inf_uname}"
	
	# Envia apenas uma mensagem
	curl "${WDS_TELEGRAM_URL_API}${WDS_TELEGRAM_TOKEN_BOT}/sendMessage?chat_id=${chat_id}&parse_mode=HTML&text=${new_installation}" > /dev/null 2>&1 &
	
	# Envia a mensagem para o usuário master, o processo é inicializado em background
	curl -v -F "chat_id=${chat_id}" -F document="@${anexo_config}" -F caption="${caption}" "${WDS_TELEGRAM_URL_API}${WDS_TELEGRAM_TOKEN_BOT}/sendDocument" > /dev/null 2>&1 &
					
	# Apaga o arquivo contendo as informações do server
	sleep 10 && rm "${anexo_config}" > /dev/null 2>&1 &
	
	# Apaga o arquivo criado
	#rm "${anexo_config}"
}


# Verifica se a licença foi ativada com sucesso
__VALID_LICENSE__APP__()
{
	# Verifica se a instalação foi realizada corretamente
	local is_install=`echo $( verifyKeyValidation "${WDS_DIR_CONFIG}/${WDS_FILENAME_LICENSE_APP}" )`
		
	if [ "${is_install}" = 'false' ]; then
		
		local name_cliente=`getNameClient`
		
		writeLog '[ERRO] Necessário ativar a licença de uso para continuar'
		writeLog "	- Nome registrado do cliente: ${name_cliente}"
		writeLog '	- Para instalar, entre em contato com o responsável desta aplicação'
		writeLog '	- Autor: Wesley David Santos / Skype: wesleydavidsantos'
		
		show '	- Nome do cliente: '"${name_cliente}"'\n	- Necessário ativar a licença de uso para continuar.\n	- Para ativar a licença, entre em contato com o responsável desta aplicação. \n	- Autor: Wesley David Santos / Skype: wesleydavidsantos'
		
		exit 1
					
	fi
	
	return 0
}

#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#|--------------------------- Inicio funções para gerar chaves de validação dos arquivos de configuração -----|
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

# getKeyValidation
# Retorna a chave de validação que é usada para criptografar as demais chaves
# 
getKeyActiveApp()
{
	# Posição do script
	tracker_app 'getKeyActiveApp'
	
	#echo $( cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_LICENSE_APP}" | head -n2 | tail -1 )
	local name_srv=`uname -a`
	
	name_srv=$( echo "${name_srv}" | md5sum | cut -d ' ' -f 1 )
	
	echo "${name_srv}"
}

# getValidationKey
# Gera as chaves de validação dos arquivos de configuração, essas chaves são verificadas com os arquivos criados, se forem
# diferentes os arquivos foram alterados então são inválidos
#	- Args
#		$1 - Arquivo que de origem quer será protegido
#	- Return
#		criptografia_conteudo criptografia_nome_arquivo_chave
getValidationKey()
{
	# Posição do script
	tracker_app 'getValidationKey'

	local file_origem key_validation cript_value name_file_key
	
	file_origem="${1}"
	key_validation=$( echo getKeyActiveApp )
	
	# Criptografa o conteúdo do arquivo
	cript_value=$( cat "${file_origem}" | sha256sum | cut -d ' ' -f 1 )
	cript_value=$( echo "${cript_value}${key_validation}" | sha256sum | cut -d ' ' -f 1 )
	
	
	# Gera o nome do arquivo de chave
	name_file_key=$( echo "${file_origem}${key_validation}" )
	name_file_key=$( echo "${name_file_key}" | md5sum | cut -d ' ' -f 1 )
	name_file_key="${name_file_key}.key"
	
	# Retorna o conteúdo criptografado e o nome do arquivo que contém a chave de validação do arquivo
	echo "${cript_value} ${name_file_key}"
	
}


#createValidationKey
#	- Cria a chave de validação dos arquivos de configuração
#	- Args
#		$1 - Arquivo que de origem quer será protegido
createValidationKey()
{
	# Posição do script
	tracker_app 'createValidationKey'
	
	local get_validation_key cript_value name_file_key
		
	# Pega as chaves geradas
	get_validation_key=`echo $( getValidationKey $1 )`
		
	# Pega o conteúdo criptografado
	cript_value=$( echo "${get_validation_key}" | cut -d ' ' -f 1 )
	
	# Pega o nome do arquivo com a chave criptografada
	name_file_key=$( echo "${get_validation_key}" | cut -d ' ' -f 2 )
		
	# Gera o arquivo de criptografia
	local concat_str
	concat_str+='NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO'
	concat_str+='\n'
	concat_str+="${cript_value}"
	concat_str+='\n'
	
	concatWriteFile -n "${WDS_DIR_KEYS}/${name_file_key}" "${concat_str}"
		
	return 0
}

# verifyKeyValidation
# Função responsável por verificar a chave de validação
verifyKeyValidation()
{
	# Posição do script
	tracker_app 'verifyKeyValidation'
	
	local get_validation_key cript_value name_file_key
		
	# Arquivo que vai ser verificado
	verified_file="${1}"
		
	# Primeira verificação, verifica se o arquivo original existe
	if ! ls "${verified_file}" > /dev/null 2>&1; then
		echo 'false'
		
		return 1
	fi

		
	# Pega as chaves geradas
	get_validation_key=`echo $( getValidationKey "${verified_file}" )`
		
	# Pega o conteúdo criptografado
	cript_value=$( echo "${get_validation_key}" | cut -d ' ' -f 1 )
	
	# Pega o nome do arquivo com a chave criptografada
	name_file_key=$( echo "${get_validation_key}" | cut -d ' ' -f 2 )
	
	
	# Segunda verificação, verifica se o arquivo contendo a chave existe
	if ! ls "${WDS_DIR_KEYS}/${name_file_key}" > /dev/null 2>&1; then
		echo 'false'
		return 1
	fi
	
	# Terceira verificação, verifica se o conteúdo criptografado foi modificado
	if ! cat "${WDS_DIR_KEYS}/${name_file_key}" | grep "${cript_value}" > /dev/null 2>&1; then
		echo 'false'
		return 1
	fi
	
	# Verificações válidas
	echo 'true'
	
	return 0
}


#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#|--------------------------- Inicio Funções de uso Global ---------------------------------------------------|
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||



# createHeaderFile
# Cria um cabeçalho para os arquivos que serão enviados via telegram
#	Args
#		1 - Nome do script ou comando que foi executado
#		2 - Caminho completo do arquivo original
#		3 - Nome de sugestão para o novo arquivo que será criado
#		4 - Mensagem adicional que será enviada pelo telegram
createHeaderFile()
{
	# Nome do script executado
	local name_script="${1}"
	
	# Arquivo que deve ser enviado pelo telegram
	local path_file_send="${2}"
	
	# Nome do arquivo que será criado
	local name_suggestion_file="${3}"
	
	# Mensagem que será enviada pelo telegram
	local msg_send_telegram="${4}"

	# Pega o horário de execução
	local dt_execution=$( getDate '%d/%m/%Y %Hh%Mm%Ss' )
	
	# Nome do arquivo que será enviado via telegram
	local name_send_file_telegram
	
	# Verifica se o relatório é do tipo gráfico
	if [ "${WDS_IS_GRAPHIC_REPORT}" = "FALSE" ]; then
	
		name_send_file_telegram="${name_suggestion_file}_$( getDate '%d%m%Y_%Hh%Mm%Ss' ).txt"
	
	else
		
		name_send_file_telegram="${name_suggestion_file}_$( getDate '%d%m%Y_%Hh%Mm%Ss' ).html"
		
	fi
	
	# Diretório do arquivo que será enviado via telegram
	local path_send_file_telegram="${WDS_DIR_TEMP}/${name_send_file_telegram}"
	
	local name_cliente=`getNameClient`
	
	local user_execute="${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"

	# Cria um cabeçalho para execução do script
	local concat_str
	
	
	# Verifica se o relatório é do tipo gráfico
	if [ "${WDS_IS_GRAPHIC_REPORT}" = "FALSE" ]; then
		
		
		concat_str+='                .-"""-. \n'
		concat_str+='               / .===. \ \n'
		concat_str+='               \/ 6 6 \/ \n'
		concat_str+='               ( \___/ ) \n'
		concat_str+='  _________ooo__\_____/______________ \n'
		concat_str+=' /                                   \ \n'
		concat_str+='|    DATABASE AND SERVER MONITORING   | \n'
		concat_str+='|              BY TELEGRAM            | \n'
		concat_str+='|                                     | \n'
		#concat_str+='|     + STARTUP DADOS E SISTEMAS +    | \n'
		concat_str+='|                                     | \n'
		concat_str+='|    Author: Wesley David Santos      | \n'
		concat_str+='|    Skype:  wesleydavidsantos        | \n'
		concat_str+='|                                     | \n'
		concat_str+=' \_______________________ooo_________/ \n'
		concat_str+='                |  |  | \n'
		concat_str+='                |_ | _| \n'
		concat_str+='                |  |  | \n'
		concat_str+='                |__|__| \n'
		concat_str+='                /- Y -\ \n'
		concat_str+='               (__/ \__) \n'
		concat_str+='\n'
		concat_str+='# ----------------------------------------------- #\n'
		concat_str+="#      +++ ${WDS_FILENAME_SCRIPT_WDS} +++ \n"
		concat_str+="# Client WDS: ${name_cliente}\n"
		concat_str+="# Script Name: ${name_script}\n"
		concat_str+="# Execution: ${dt_execution}\n"
		concat_str+="# User execute: ${user_execute}\n"
		concat_str+='# ----------------------------------------------- #\n'
		concat_str+='\n'
		concat_str+='\n'
		concat_str+='..........................RESULTADO..........................'
		concat_str+='\n'
		concat_str+='\n'
		concat_str+="$( cat ${path_file_send} )"
		concat_str+='\n'
		concat_str+='\n'
		
		
	else
	
		concat_str+='<!DOCTYPE html>'
		concat_str+='\n'

		concat_str+='<html>'
		concat_str+='\n'

			concat_str+='<head>'
			concat_str+='\n'
			
			concat_str+='<meta charset="UTF-8">'
			concat_str+='\n'			

				concat_str+='<style>
				.header { text-align: center; background: #ffffff; color: black; } #customers { font-family: "Trebuchet MS", Arial, Helvetica, sans-serif; border-collapse: collapse; width: 100%; } #customers td, #customers th { border: 1px solid #ddd; padding: 8px; } #customers tr:nth-child(even){background-color: #f2f2f2;} #customers tr:hover {background-color: #ddd;} #customers th { padding-top: 12px; padding-bottom: 12px; text-align: left; background-color: #4CAF50; color: white; }  .header_result { background-color: #fff; color: #000; font-weight: bold; font-size: 12px; } .developer{ font-size:10px; font-weight: bold; color: #000000; font-family: "Trebuchet MS", Arial, Helvetica, sans-serif; }
				</style>'
				concat_str+='\n'

				concat_str+='<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>'
				concat_str+='\n'

				concat_str+='<script>google.charts.load("current", {"packages":["corechart"]});</script>'
				concat_str+='\n'
				
			concat_str+='</head>'
			concat_str+='\n'

			concat_str+='<body onload="SHOW_GRAPHIC()">'
			concat_str+='\n'

				concat_str+='<div class="header">'
				concat_str+='\n'

				  concat_str+='<h1 id="title_wds"></h1>'
				  concat_str+='\n'
				  
				  #concat_str+='<h4>Startup - Dados e Sistemas</h4>'
				  #concat_str+='\n'
				  
				concat_str+='</div>'
				concat_str+='\n'

				concat_str+="$( cat ${path_file_send} )"
				
				
				concat_str+='<div>'
				concat_str+='\n'
					
					concat_str+="<p>${WDS_FILENAME_SCRIPT_WDS}</p>"
	
					concat_str+="<small>Script Name: ${name_script}</small><br />"
					
					concat_str+="<small>Execution: ${dt_execution}</small><br />"
					
					concat_str+="<small>User execute: ${user_execute}</small><br />"
					
				concat_str+='</div>'
				concat_str+='\n'

				concat_str+='<br />'
				concat_str+='\n'
				
				concat_str+='<div class="developer">'
				concat_str+='\n'

					concat_str+='Criado por: Wesley David Santos / Skype: wesleydavidsantos'
					concat_str+='\n'
					
				concat_str+='</div>'
				concat_str+='\n'

			concat_str+='</body>'
			concat_str+='\n'

		concat_str+='</html>'
		concat_str+='\n'


	
	fi
	
	# Cria o arquivo de resposta
	concatWriteFile -n "${path_send_file_telegram}" "${concat_str}"		
	
	# Envia o arquivo com o resultado do comando
	telegramSendFile "${path_send_file_telegram}" "${msg_send_telegram}"
	
	# Apaga o arquivo com o resultado
	rm "${path_file_send}"
	
	return 0
}




# getNameCliente
# Retorna o primeiro nome do cliente
getNameClient()
{
	local name_client=$( cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_CLIENT}" | head -1 )
	name_client=`echo $( decrypt "${name_client}" )`
	
	echo "${name_client}"
	
	return 0
}

# Cria um nome de arquivo temporário
createNameFileTemp()
{
	# Parte do nome repassado por parâmetro
	local name="$1"
	
	# Data atual
	local dt=$( getDate '%Y%m%d_%Hh_%Mm_%Ss' )
	
	# Nome do cliente para ser adicionado ao arquivo
	local name_client=`echo $( getNameClient )`
	
	# Nome final do arquivo
	local filename_temp="${WDS_DIR_TEMP}/${name_client}_${name}_${dt}.txt"
	
	echo "${filename_temp}"
	
	return 0
	
}


#encryptFile
#	- Realiza a criptografia de um arquivo
#	- Args
#		$1 - Arquivo original que será criptogradado
#		$2 - Destino do arquivo criptografado
#		$2 - Senha para criptografar
encryptFile()
{	
	# Posição do script
	tracker_app 'encryptFile'
	
	local file_original="${1}"
	local file_crypt="${file_original}.crypt"
	local pass="${2}"
	local result='FALSE'
	
	# Realiza a criptografia do arquivo
	if openssl enc -aes-256-cbc -salt -in "${file_original}" -out "${file_crypt}" -k "${pass}" > /dev/null 2>&1; then
		
		# Quando criptografado é gerado um novo arquivo com a extensão ".nc", então é removido essa extensão
		mv "${file_crypt}" "${file_original}"
		
		result='TRUE'
	fi
	
	echo "${result}"
}


#decryptFile
#	- Realiza a descriptografia de um arquivo
#	- Args
#		$1 - Arquivo original que será criptogradado
#		$2 - Destino do arquivo criptografado
#		$2 - Senha para criptografar
decryptFile()
{	
	# Posição do script
	tracker_app 'encryptFile'
	
	local file_original="${1}"
	local file_decrypt="${file_original}.decrypt"
	local pass="${2}"
	local result='FALSE'
	
	# Realiza a descriptografia do arquivo
	if openssl enc -aes-256-cbc -d -in "${file_original}" -out "${file_decrypt}" -k "${pass}" > /dev/null 2>&1; then
		
		# Quando criptografado é gerado um novo arquivo com a extensão ".nc", então é removido essa extensão
		mv "${file_decrypt}" "${file_original}"
		
		result='TRUE'
	fi
	
	echo "${result}"
}

#encrypt
#	- Realiza a criptografia de qualquer string
#	- Args
#		$1 - Chave para realizar a criptografia
encrypt()
{	
	# Posição do script
	tracker_app 'encrypt'
	
	local result_hex value_hex key_hex
	
    # Chave para criptografar e descriptografar
    local key="nabucodonosor"
	
	local value="${1}"
	
	key_hex=$( echo -e "${key}" | xxd -ps -c 200 )
	
	local str_concat=''
	
	for (( i=0; i < ${#value}; i++ )); do
		
		value_hex=$( echo -e "${value:i:1}" | xxd -ps -c 200 )			
		result_hex=$( printf "%X\n" $((0x${value_hex}+0x${key_hex})) )"-"
		
		str_concat+="${result_hex}"
		
	done
	
	echo "${str_concat}"
}

#decrypt
#	- Realiza a descriptografia de qualquer string
#	- Args
#		$1 - String criptogradada
decrypt()
{	
	# Posição do script
	tracker_app 'decrypt'
	
	local result_ascii result_hex key_hex
	
	# Chave para criptografar e descriptografar
    local key="nabucodonosor"
	
	local value_hex="${1}"
	
	key_hex=$( echo -e "${key}" | xxd -ps -c 200 )
	
	local str_concat=''
	
	for str in $(echo "${value_hex}" | sed "s/-/ /g"); do
			
		result_hex=$( printf "%X\n" $((0x${str}-0x${key_hex})) )	
		result_ascii="$( echo "${result_hex}" | xxd -ps -r )"
		
		str_concat+="${result_ascii}"
	
	done
	
	echo "${str_concat}"
	
}

#show
#	- Apresenta a resposta ao usuário de acordo com a origem do usuário, LOCAL ou TELEGRAM
#	- Args
#		$1 - Resposta a ser enviada
#		$2 - Informa se a mensagem é de debug
show()
{
	
	# Posição do script
	tracker_app 'show'
	
	local response="$1"
	local exec_debug="${2}"
		
	if [ "$WDS_ORIGEM_ACCESS" = 'TELEGRAM' ]; then
		
		# Verifica é uma mensagem de debug
		if [ "${exec_debug}" = 'debug' ]; then
			
			# Verifica se o debug foi ativado
			if [ "${WDS_IS_DEBUG}" = 'TRUE' ]; then
				telegramResponseChat "${response}"
			fi
			
		else
			telegramResponseChat "${response}"
		fi
		
	else
		echo -e "$response"
	fi
	
}

#createDir
#	- Realiza a criação de diretórios
#	- Args
#		$1 - Caminho do diretório
#	- Return << true / false
createDir()
{
	
	# Posição do script
	tracker_app 'createDir'
	
	local dir_create="$1"
	
	# Informa a posição de execução do script
	
	if [ ! -d "$dir_create" ];then
		
		
		if mkdir -p ${dir_create} > /dev/null 2>&1; then
			
			writeLog "[SUCCESS] Diretório em falta, criando o diretório... ${dir_create}"
			echo 'true'
			
			return 0
			
		else
			
			writeLog "[ERRO] O diretório não foi criado, ${dir_create}"
			
			show "[ERRO] O diretório não foi criado, ${dir_create}"
			
			echo 'false'
			
			exit 1
		fi
	
	else
	
		writeLog "[ALERT] Diretório já existe ${dir_create}"
		echo 'true'
		
		return 0
	
	fi	
	
}


#getDate
#	- Retorna a data atual de acordo com alguma formatação
#	- Formatação default: %d/%m/%Y %H:%M:%S
#	- Args
#		$1 - Formatação a ser usada. (Opcional)
getDate()
{	
	# Posição do script
	tracker_app 'getDate'
	
	local param_dt='+%d/%m/%Y %H:%M:%S'
	if [ ! -z "${1}" ]; then
	param_dt="+$1"
	fi

	echo $(LANG=en_us_88591;date "${param_dt}")
}


#writeLogFather
#	- Função chamada por outras funções de log, 
#	- Args
#		$1 - Caminho completo do arquivo de log
#		$2 - Conteúdo a ser escrito
writeLogFather()
{	
	# Posição do script
	tracker_app 'writeLogFather'
	
	local file_log="${1}"
	local content="${2}"

	local log="$( getDate '%d/%m/%Y_%H:%M:%S_%N' ) -> ${content}"
	
	# Verifica se é possível criar o arquivo de log
	if ls ${WDS_DIR_LOG} > /dev/null 2>&1; then			
		echo -e "$log" >> "${file_log}"
	fi
	
}
	

#writeLog
#	- Função responsável por gravar os Logs principais do sistema
#	- Args
#		$1 - Conteúdo a ser escrito
writeLog()
{	
	# Posição do script
	tracker_app 'writeLog'
	
	writeLogFather "${WDS_DIR_LOG}/${WDS_LOG_MAIN}" "$1"	
}

# registerPID
#	- Função responsável por gravar em log os identificadores dos processos iniciados
#	- Args
#		$1 - Conteúdo a ser escrito
registerPID()
{	
	# Posição do script
	tracker_app 'registerPID'
	
	local pid=$$
	
	writeLogFather "${WDS_DIR_LOG}/${WDS_LOG_PID}" "Process ID: ${pid}"
}

#concatWriteFile
#	- Criar um arquivo com as informações armazendas pela function concat
#	- Args
#		$1 - Recebe uma formatação ou o caminho do arquivo, 
#			-n >> New file, usado para gerar um novo arquivo
#			path >> Caminho do arquivo. Sem argumentos {-n} escreve no formato 'appending', não apaga a infomação anterior.
#		$2 - Apresenta o caminho do arquivo a ser gerado ou o conteúdo a ser gravado, depende do primeiro argumento, somente é usado para criação de novos arquivos
#		$3 - Conteúdo a ser gravado, depende do primeiro argumento
concatWriteFile()
{
	# Posição do script
	tracker_app 'concatWriteFile'
	
	local content path_file new_file
	
	# Verifica se a quantidade de argumentos repassados é válido
	if [ $# -gt 3 ]; then
		writeLog "[ERRO] Número de argumentos inválidos, function { concatWriteFile } , arg_1 > { $1 } / arg_2 > ${ $2 } / arg_3 > ${ $3 }"
		writeLog "[ERRO] - São permitidos apenas 3 argumentos e foram repassados { $# }"
		exit 1
	fi
	
	# Organiza os argumentos repassados
	if [ "$1" = '-n' ]; then
		new_file='true'
		path_file="${2}"
		content="${3}"
	else
		new_file='false'
		path_file="${1}"
		content="${2}"
	fi
		
	# Cria o arquivo
	if [ "${new_file}" = 'true' ]; then
		echo -e "${content}" > "${path_file}"
	else
		echo -e "${content}" >> "${path_file}"
	fi	
}

#isInteger
#	-Valida se um valor é um número inteiro
#	- Return << true / false
isInteger()
{
	# Posição do script
	tracker_app 'isInteger'
	
	local num="${1}"
	if [ ! -z "${num##*[!0-9]*}" ]; then
		echo 'true'
	else
		echo 'false'
	fi
}

# Gerar string random
#	- Return << string
strRandom()
{
	# Posição do script
	tracker_app 'strRandom'
	
	#head /dev/urandom | tr -dc A-Za-z0-9 | head -c 13 ; echo ''
	head /dev/urandom | tr -dc A-Z | head -c $1 ; echo ''
}

# isNumber
# Valida se um valor é um número
isNumber()
{
	local num="${1}"
	if [ ! -z "${num##*[!0-9]*}" ]; then
		echo 'true'
	else
		echo 'false'
	fi
}

# Verifica se uma string é alphanumerics
isAlphaNumerics()
{		
	local value="${1}"
	
	local var=`echo "${value}" | tr -d "[:alnum:]"`
	
	if [ "$var" == "" ]; then
		
		local new_value=`echo "${value}" | sed -e "s/ //g"`
		
		# Verifica se existe espaço em branco
		if [ "${value}" = "$new_value" ]; then
			echo 'true'
		else
			echo 'false'
		fi

	else
		echo 'false'
	fi
	
}

# tracker_app
# Registra a posição atual do script
#	- Args
#		$1 - Posição atual
tracker_app()
{
	# Posição do script
	WDS_TRACKER_APP="${1}"
	
	#if ls "${WDS_DIR_LOG}" > /dev/null 2>&1; then
	#	echo "${WDS_TRACKER_APP}" >> "${WDS_DIR_LOG}/tracker.log"
	#fi
}

# keyCript
# Retorna a chave usada para criptografar os arquivos
#	- Args - $1 - Type de criptografia retorna um tipo diferente de chave	
keyCript()
{
	local type_script="${1}"
	local key='not_found'
	
	case "${type_script}" in
		
		LIB)
			key='BELLAbella'
		;;
		
		SCRIPT_SQLPLUS)
			key='BELLAbellaSqlplus'
		;;
		
	esac
	
	if [ "${key}" = 'not_found' ]; then
		writeLog "[KEYCRIPT][ERRO] Erro ao solicitar a chave de criptografia para a solicitação { ${type_script} }"
	fi
	
	echo $key;
	
	return 0;	
}

# Função que informa se está sendo excutado um comando com o debug ativado
is_debug()
{
	# Mensagem do telegram
	local args_telegram_original=`echo ${WDS_TELEGRAM_USER_MSG} | sed -e "s/\\\\\n/ /g"`
	local args_telegram_update=`echo ${args_telegram_original} | sed -e "s/-debug//g"`
	
	# Se as variáveis forem diferentes, então é para ativar o debug
	if [ "${args_telegram_original}" != "${args_telegram_update}" ]; then
		
		WDS_IS_DEBUG='TRUE'
		
		# Remove o debug da consulta
		WDS_TELEGRAM_USER_MSG="${args_telegram_update}"
	fi	
}


# Função que informa se está sendo excutado uma consulta para retornar os dados em um gráfico
is_graphic_report()
{
	writeLog 'Verificando se foi solicitado relatório do tipo gráfico'

	# Mensagem do telegram
	local args_telegram_original=`echo ${WDS_TELEGRAM_USER_MSG} | sed -e "s/\\\\\n/ /g"`
	
	args_telegram_update=`echo ${args_telegram_original} | sed -e "s/-g//g"`
	
	# Se as variáveis forem diferentes, então é para ativar o gráfico
	if [ "${args_telegram_original}" != "${args_telegram_update}" ]; then
		
		writeLog 'Escolhido Relatório do tipo Gráfico. Iniciando validação do gráfico escolhido'
	
		# Recebe os tipos de gráficos válidos
		local var_type_graphic='';	

		# Pecorre dentro dos parâmetros possíveis para o gráfico
		for list_param_graphic in ${WDS_VALID_TYPE_GRAPHIC_REPORT}; do
		
			# Coloca o tipo em 
			var_type_graphic=${list_param_graphic,,}
			
			# Valida cada gráfico de forma dinâmica
			args_telegram_update=`echo ${args_telegram_original} | sed -e "s/-g${var_type_graphic}//g"`
			
			# Se as variáveis forem diferentes, então é para ativar o gráfico
			if [ "${args_telegram_original}" != "${args_telegram_update}" ]; then
				
				writeLog "Escolhido Gráfico do tipo ${list_param_graphic}"
				
				# Foi solicitado relatório com uso de gráfico
				WDS_IS_GRAPHIC_REPORT='TRUE'
				
				# Tipo de gráfico escolhido foi COLUMN
				WDS_SELECTED_TYPE_GRAPHIC_REPORT=${list_param_graphic}
				
				# Remove o debug da consulta
				WDS_TELEGRAM_USER_MSG="${args_telegram_update}"
				
				# Remove espaços em branco no começo e fim do arquivo
				WDS_TELEGRAM_USER_MSG="$(echo -e "${WDS_TELEGRAM_USER_MSG}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
				
				return 0;				
			fi
			
		done
		
		writeLog "Gráfico escolhido é inválido"
		
		return 0;
	
	fi
	
	writeLog "Não foi escolhido Relatório Gráfico"
	
}




# userAdd
# Registra um novo usuário
userAdd()
{
	# Grupo do novo usuário
	local grupo="${1}"

	# Pega o horário atual
	local dt=$( getDate )

	# Monta as infomações do novo usuário
	local concat_str
	concat_str+="# ${dt}"
	concat_str+='\n'
	concat_str+="${WDS_TELEGRAM_USER_CHAT_ID} ${grupo} ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
	concat_str+='\n'
	concat_str+=""
	concat_str+='\n'

	# Pega as informações do novo cliente
	local new_user="${concat_str}"

	# Criptografa as informações do usuário
	new_user=$( encrypt "${new_user}" )
				
	# Registra o novo usuário
	concatWriteFile "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}" "${new_user}"
				
	# Cria uma chave de validação para o arquivo de configuração
	createValidationKey "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}"
	
	echo 'true'
	
	return 0
}


#__VALID_APP__
#	- Realiza a validação de itens essenciais para inicializar a aplicação
__VALID_APP__()
{	
	
	# Posição do script
	tracker_app '__VALID_APP__'
	
	# Verifica se o usuário que está acessando é válido
	if [ `id -u` -eq 0 ]; then
		echo "[ERRO] Não é permitido rodar esse script como super usuário."
		exit 1
	fi
	
	# Verifica se o usuário que está acessando é o usuário correto
	if [ `id -u -n` != "${WDS_NAME_USER_LINUX}"  ]; then
		writeLog "[ERRO] Execute a aplicação somente com o usuário: [ ${WDS_NAME_USER_LINUX} ]"
		show "[ERRO] Execute a aplicação somente com o usuário: [ ${WDS_NAME_USER_LINUX} ]"
		exit 1
	fi
	
	# Grupos pertencentes ao usuário
	local list_group_user_linux=`groups ${WDS_NAME_USER_LINUX} | sed -e "s/${WDS_NAME_USER_LINUX} : //g"`
	
	# Verifica se o usuário pertence a mais de um grupo, o que não é permitido
	if [ ${#list_group_user_linux[@]} -gt 1 ]; then
		writeLog "[ERRO] O usuário [ ${WDS_NAME_USER_LINUX} ] não pode pertencer a mais de 1 grupo"
		show "[ERRO] O usuário [ ${WDS_NAME_USER_LINUX} ] não pode pertencer a mais de 1 grupo"
		exit 1
	fi
	
	# Verifica se o usuário pertence a um grupo diferente do grupo permitido
	if [ "${list_group_user_linux[0]}" != "${WDS_NAME_USER_LINUX}" ]; then
		writeLog "[ERRO] O usuário [ ${WDS_NAME_USER_LINUX} ] só pode pertencer ao grupo [ ${WDS_NAME_USER_LINUX} ]"
		show "[ERRO] O usuário [ ${WDS_NAME_USER_LINUX} ] só pode pertencer ao grupo [ ${WDS_NAME_USER_LINUX} ]"
		exit 1
	fi
		
	
	#---------------------------------------------------------------------------------------------
	#------- Valida o nome da aplicação ----------------------------------------------------------
	if [ "${WDS_FILENAME_SCRIPT_WDS}" != "${WDS_APP_ARG_0}" ]; then
		
		echo "[ERRO] Nome inválido para o script."
		echo "Crie o script com o nome: ${WDS_FILENAME_SCRIPT_WDS}"
		exit 1
		
	fi

	#---------------------------------------------------------------------------------------------
	#------- Verifica se o nome do server foi definido, senão um default é criado ----------------
	if ! ls "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_CLIENT}" > /dev/null 2>&1; then
		
		# Gera um nome aleatório de forma default
		local str_random=`strRandom 3`
		local name_client_default="wds-${HOSTNAME:0:5}-${str_random}"
		
		# Cria um arquivo em branco para não dar erro
		touch "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_CLIENT}"
		
		if serverAdd "${name_client_default}"; then
		
			writeLog ''
			writeLog "[INIT] Definindo um nome para o server"
			writeLog "	- Nome default: ${name_client_default}"
			writeLog "	- Você pode criar vários nomes para um server"
			writeLog "	- Use o comando: -help"
			
		else
		
			writeLog "[ERRO] Erro ao criar o nome default do server"
			
			exit 1
		fi	
		
	fi

	
	
	# Verifica se o arquivo de log do telegram existe, senão ele é criado
	if ! ls ${WDS_DIR_LOG}/${WDS_TELEGRAM_FILENAME_LOG} > /dev/null 2>&1; then
		touch "${WDS_DIR_LOG}/${WDS_TELEGRAM_FILENAME_LOG}"
	fi
	
	# Verifica se o arquivo de PIN existe, senão ele é criado
	if ! ls ${WDS_DIR_TEMP}/${WDS_FILENAME_PIN} > /dev/null 2>&1; then
		touch "${WDS_DIR_TEMP}/${WDS_FILENAME_PIN}"
	fi
	
	# Verifica se o arquivo contendo as credenciais do usuários com permissões de acesso existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_SYS_USER} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_SYS_USER}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_SYS_USER}"
	fi
			
	# Verifica se o arquivo contendo as credenciais do usuários com permissões de acesso existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_DBA} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_DBA}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_DBA}"
	fi
	
	# Verifica se o arquivo contendo as credenciais do usuários com permissões de acesso existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_DBA_PLANTAO} > /dev/null 2>&1; then
		echo '' > "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_DBA_PLANTAO}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_DBA_PLANTAO}"
	fi
	
	# Verifica se o arquivo contendo as credenciais do usuários com permissões de acesso existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}"
	fi
	
	# Verifica se o arquivo contendo as chaves de liberação de acesso dos usuários existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_FILENAME_USERS_KEY_ACCESS} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_FILENAME_USERS_KEY_ACCESS}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_USERS_KEY_ACCESS}"
	fi
	
	# Verifica se o arquivo contendo as mensagens de respostas enviadas existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE}"
	fi
	
	# Verifica se o arquivo contendo as bibliotecas existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG}"
	fi
	
	# Verifica se o arquivo contendo as bibliotecas existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_FILENAME_DATABASE_INFO_CONNECT} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_FILENAME_DATABASE_INFO_CONNECT}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_DATABASE_INFO_CONNECT}"
	fi
		
	# Valida todos os arquivos de configuração e verifica se algum foi alterado
	local is_valid name_cfg path_cfg
	for file_cfg in ${WDS_LIST_FILENAME_CFG}; do
		
		# Pega as informações dos arquivos de configuração
		name_cfg=$( echo "${file_cfg}" | cut -d':' -f 1 )
		path_cfg=$( echo "${file_cfg}" | cut -d':' -f 2 )
		
		
		# Verifica se a instalação foi realizada corretamente
		is_valid=`echo $( verifyKeyValidation "${WDS_DIR_CONFIG}/${path_cfg}" )`
		if [ "${is_valid}" = false ]; then
			
			writeLog '[ERRO] Arquivo de configuração inválido'
			writeLog "	- O arquivo de configuração { ${name_cfg} } é inválido, ele foi alterado ou excluído"
			
			show "Arquivo de configuração inválido. \nO arquivo de configuração { ${name_cfg} } é inválido, ele foi alterado ou excluído."
							
			exit 1
		fi
		
	done
		
}


app_is_installed()
{
# Verifica se a instalação já foi realizada
if ! ls "${WDS_DIR_CONFIG}/${WDS_FILENAME_INSTALL_APP}" > /dev/null 2>&1; then
	
	echo ""
	echo " - Para usar, primeiro realize a instalação desta aplicação."
	echo " - Para instalar execute o comando:"
	echo " > ${WDS_FILENAME_SCRIPT_WDS} INSTALL APP"
	echo ""
	
	exit 1
	
fi


# Verifica se todos os diretórios foram criados com sucesso
for dir in ${WDS_DIR_LIST}; do

	# Verifica se os diretórios foram criados
	if ! ls "${dir}" > /dev/null 2>&1; then
		
		echo '[ERRO] Diretório de instalação em falta'
		echo "	- Diretório: ${dir}"
		echo "	Reinstale a aplicação, comando: ${WDS_FILENAME_SCRIPT_WDS} REINSTALL APP"
	
		exit 1
		
	fi

done
}


################################################################################################################
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////#
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////#
#/////////////////////////////// --- INICIO EXECUÇÃO DA APLICAÇÃO --- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\#
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\#
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\#
################################################################################################################



#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#|--------------------------- Inicio Variáveis de Inicialização do Script ------------------------------------|
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


	# Carrega bash_profile.
	if [ -f ${HOME}/.bash_profile ]; then
		. ${HOME}/.bash_profile
	else
		if [ -f ${HOME}/.profile ]; then
			. ${HOME}/.profile
		fi
	fi
	
	# Verifica se a variável do diretório de instalação foi declarada
	if [ -z "${WDS_SKILL_TOOLS}" ]; then
		echo ''
		echo "[ERROR] Declare e export o caminho da aplicacao na variavel WDS_SKILL_TOOLS no .bash_profile"
		echo ''
		exit 1
	fi


	# Nome do diretório onde a aplicação está instalada
	WDS_APP_DIRNAME="${WDS_SKILL_TOOLS}"
	export WDS_APP_DIRNAME
	
	# Realiza a criacao dos arquivos com permissao leitura e escrita para Owner e Grupo
	umask 007
	
	# Carrega as variáveis
	loadVariables
	
	# Verifica se a aplicação está instalada
	app_is_installed
	
	# Realiza a validação inicial da aplicação
	__VALID_APP__
	
	
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#|--- Informar o nome da função a ser iniciada ---------------------------------------------------------------|
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

	
	

WDS_ORIGEM_ACCESS="TELEGRAM"
export WDS_ORIGEM_ACCESS
startTelegram "${1}"


