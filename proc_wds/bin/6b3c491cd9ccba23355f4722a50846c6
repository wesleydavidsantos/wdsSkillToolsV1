#!/bin/bash
# proccessMsgTelegram
# Processa cada mensagem enviada
#	- Args
#		$1 - json contendo a mensagem
startTelegram()
{
	# Posição do script
	tracker_app 'startTelegram'
	
	local msg="${1}"
	
	local update_id=$(echo "${msg}" | jq -r ".update_id")
	
	
	# Atribuí as variáveis globais os valores da mensagem enviada por telegram
	WDS_TELEGRAM_UPDATE_ID=${update_id}
	WDS_TELEGRAM_USER_CHAT_ID=$(echo "${msg}" | jq -r ".message.chat.id")
	WDS_TELEGRAM_USER_FIRST_NAME=$(echo "${msg}" | jq -r ".message.chat.first_name")
	WDS_TELEGRAM_USER_LAST_NAME=$(echo "${msg}" | jq -r ".message.chat.last_name")
	WDS_TELEGRAM_USER_MSG_ID=$(echo "${msg}" | jq -r ".message.message_id")
	WDS_TELEGRAM_USER_MSG=$(echo "${msg}" | jq -r ".message.text")
	
	# Verifica se a consulta possui anexo
	if [ "${WDS_TELEGRAM_USER_MSG}" = 'null' ]; then
		WDS_TELEGRAM_USER_MSG=$(echo "${msg}" | jq -r ".message.caption")
	fi
	
	
	# Verifica se existe anexo na mensagem
	WDS_TELEGRAM_DOCUMENT_FILE_NAME=$(echo "${msg}" | jq -r ".message.document.file_name")
	WDS_TELEGRAM_DOCUMENT_MIME_TYPE=$(echo "${msg}" | jq -r ".message.document.mime_type")
	WDS_TELEGRAM_DOCUMENT_FILE_ID=$(echo "${msg}" | jq -r ".message.document.file_id")
	WDS_TELEGRAM_DOCUMENT_FILE_SIZE=$(echo "${msg}" | jq -r ".message.document.file_size")
	
				
	###########################################
	# A partir daqui é minha responsabilidade #
	###########################################
	
	#writeLog "Telegram Mensagem - update_id ${update_id} - é minha responsabilidade"
	
	# Verifica se é para ativar o debug
	is_debug
	
	# Realiza a autenticação do usuário
	telegramAuthUser
	
	# Verifica se a permissão é aprovada
	if [ $? = 1 ]; then
	
		writeLog "Permissão negada, usuário ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"			
		exit 1
		
	fi		
	
	
	writeLog "Iniciando a interação com o usuário ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
	
	# Pega o nível de acesso do telegram
	WDS_TELEGRAM_LEVEL_USER=`echo $( telegramGetLevelAccessUser )`
	
	# Verifica se é uma chamada para todas as aplicações
	if [ "$( telegramArgMenu 1 )" = 'all' ]; then
		WDS_TELEGRAM_TYPE_CALL='ALL'
	fi

	# Verifica se a chamada é vinda de um cliente, se sim ele não pode enviar o comando all
	if [ "${WDS_TELEGRAM_LEVEL_USER}" = 'CLIENTE' ]; then
		
		# Verifica se é um comando para todos os clientes
		if [ "${WDS_TELEGRAM_TYPE_CALL}" = 'ALL' ]; then
		
			writeLog "Comando all inválido"
			show "Comando all inválido"
			
			exit 1
			
		fi
		
		# Verifica se é um comando de PIN, para cliente ele é inválido, pois um cliente já trabalha desta forma
		if [ "$( telegramArgMenu 1 )" = 'pin' ]; then
		
			writeLog "Comando pin inválido"
			show "Comando pin inválido"
			
			exit 1
			
		fi
		
	fi
	
	# Inicializa a interação com as informações do usuário
	telegramInteract		

}

# telegramGetLevelAccessUser
# Pega o nível de acesso do usuário que está acessando
telegramGetLevelAccessUser()
{	
	# Criptografa a chave de acesso do usuário
	local chat_id_cript=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID}" )
	
	local level_access_cript
	local level_access='NULL'	
	
	# Verifica se o usuário está cadastrado
	if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${chat_id_cript}" > /dev/null 2>&1; then
		
		local user_info=`echo $( cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${chat_id_cript}" )`
		
		for lvl in 'ADMIN' 'ANALISTA' 'DBA' 'CLIENTE'; do
			
			# Criptografa o nível de acesso para realizar a consulta
			level_access_cript=$( encrypt "${lvl}" )
		
			# Verifica o nível de acesso do usuário
			if echo ${user_info}|grep "${level_access_cript}" > /dev/null 2>&1; then
				level_access="${lvl}"
				break				
			fi
		
		done
		
	fi
	
	echo "${level_access}"
		
	return 0
}

# telegramAccessLevel
# Verifica se o nível de acesso do usuário é permitido para a ação solicitada
telegramAccessLevel()
{
	# Posição do script
	tracker_app 'telegramAccessLevel'

	# Recebe como parâmetro o nível de permissão requerida para acesso
	local level_required="${1^^}"
	
	
	case ${level_required} in
		
		# Level ADMIN
		ADMIN)
			# Criptografa o status da permissão e verifica se ele é aprovado
			level_required_cript=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ${level_required}" )
	
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript}" > /dev/null 2>&1; then
					return 0
			fi
		;;
		
		# Level DBA
		DBA)
			
			# Criptografa o status da permissão e verifica se ele é aprovado
			level_required_cript_admin=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ADMIN" )
			level_required_cript=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ${level_required}" )
		
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript_admin}" > /dev/null 2>&1; then
				return 0
			fi
			
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript}" > /dev/null 2>&1; then
				return 0
			fi
		;;
		
		# Level ANALISTA
		ANALISTA)
			
			# Criptografa o status da permissão e verifica se ele é aprovado
			level_required_cript_admin=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ADMIN" )
			level_required_cript_dba=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} DBA" )
			level_required_cript=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ${level_required}" )
		
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript_admin}" > /dev/null 2>&1; then
				return 0
			fi
			
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript_dba}" > /dev/null 2>&1; then
				return 0
			fi
			
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript}" > /dev/null 2>&1; then
				return 0
			fi
		;;
		
		# Level CLIENTE
		CLIENTE)
			
			# Criptografa o status da permissão e verifica se ele é aprovado
			level_required_cript_admin=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ADMIN" )
			level_required_cript_dba=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} DBA" )
			level_required_cript_startup=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ANALISTA" )
			level_required_cript=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID} ${level_required}" )
		
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript_admin}" > /dev/null 2>&1; then
				return 0
			fi
			
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript_dba}" > /dev/null 2>&1; then
				return 0
			fi
			
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript_startup}" > /dev/null 2>&1; then
				return 0
			fi
			
			if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${level_required_cript}" > /dev/null 2>&1; then
				return 0
			fi
		;;
		
		*)
			writeLog "Permissão não existe: ${level_required}"
			show "Permissão não existe: ${level_required}"
		;;
	esac	
	
	# Permissão Negada
	writeLog "Nível de acesso negado do usuário ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
	
	show "Você não possui privilégio suficiente para está ação."
	
	exit 1			
	
}

# telegramAuthUser
# Realiza a autenticação do usuário para uso da aplicação pelo telegram
telegramAuthUser()
{
	# Posição do script
	tracker_app 'telegramAuthUser'
	
	# Status da autorização
	local is_permission='false'
	
	# Criptografa a chave do usuário para verifica se ele já foi cadastrado
	local chat_id_cript=$( encrypt "${WDS_TELEGRAM_USER_CHAT_ID}" )

	# Verifica se é um usuário novo, do tipo MASTER
	if ! cat "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}" |grep "${chat_id_cript}" > /dev/null 2>&1; then
		
		# Verifica se o usuário que está sendo cadastrado é o usuário Master da Aplicação
		if [ "${WDS_TELEGRAM_USER_MASTER}" = "${WDS_TELEGRAM_USER_CHAT_ID}" ]; then
			
			# Cadastra o usuário
			userAdd 'ADMIN'
			
			#show 'Usuário Master cadastrado com sucesso'
						
		fi
		
	fi
	
	################################################################
	# A partir daqui a aplicação já deve estar instala com sucesso #
	################################################################
	
	# Verifica se a aplicação já foi instalada ou se está solicitando a instalação da aplicação
	if [ "$( telegramGetArgs 2 )" != "START_LICENSE" ]; then
		
		# Realiza a chamada para validar a instalação da aplicação
		__VALID_LICENSE__APP__
	
	fi
	
		
	# Verifica se é um usuário novo com uma chave válida para cadastro
	if ! cat "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}" |grep "${chat_id_cript}" > /dev/null 2>&1; then
			
		# Verifica se a chamada é para criar um novo usuário, esse novo usuário só é permitido através de uma chave
		local create_user=$( telegramArgMenu 1 )
		if [ "${create_user}" = 'wds' ]; then
				
			writeLog "Acesso aprovado do usuário ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}, para se cadastrar no sistema"
				
			return 0
			
		else
		
			writeLog "Usuário desconhecido, acesso negado. ${create_user}"
			
			show "Usuário desconhecido, acesso negado."
			
			exit 1
			
		fi		
		
	fi
		
		
	#########################################################################################################
	# Se entrou aqui, então já é um usuário cadastrado, desta forma verifica se ele tem permissão de acesso #
	#########################################################################################################
	
	
	writeLog "Verifica o nível de acesso do usuário"
	
	# Verifica se é um usuário cadastrado, senão o acesso é negado
	if cat ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}|grep "${chat_id_cript}" > /dev/null 2>&1; then
	
		writeLog "Acesso aprovado"
		writeLog "	- ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
		writeLog "	- Nível de acesso: "`echo $( telegramGetLevelAccessUser )`
				
		return 0
	
	fi
	
	# Acesso negado
	writeLog "Acesso negado do usuário ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"

	show "Acesso negado"

	exit 1			
	
}






# telegramGetArgs
# Pega cada argumento repassado na mensagem do usuário, os argumentos são separados por espaço em branco
#	- Args
#		$1 - json contendo a mensagem
telegramGetArgs()
{
	# Posição do argumento a ser retornado
	local position="${1}"
	
	# Pega o nível de acesso do telegram
	WDS_TELEGRAM_LEVEL_USER=`echo $( telegramGetLevelAccessUser )`
	export WDS_TELEGRAM_LEVEL_USER
	
	
	# Verifica se tem um PIN ativo para este usuário que está acessando
	if cat "${WDS_DIR_TEMP}/${WDS_FILENAME_PIN}" | grep "${WDS_TELEGRAM_USER_CHAT_ID}" > /dev/null 2>&1; then
		WDS_TELEGRAM_ACCESS_PIN='YES'
		export WDS_TELEGRAM_ACCESS_PIN				
	fi
	
	# Verifica se o tipo de acesso é de cliente, se sim então as posições dos argumentos são diferentes
	if [ "${WDS_TELEGRAM_LEVEL_USER}" = 'CLIENTE' ] || [ "${WDS_TELEGRAM_ACCESS_PIN}" = 'YES' ]; then
		
		# Flag para validar se será necessário mudar a posição do argumento
		local update_position='TRUE'
		
		# Se estiver usando PIN, verifica se está sendo setado o nome do cliente
		if [ "${WDS_TELEGRAM_ACCESS_PIN}" = 'YES' ]; then
		
			# Mensagem do telegram para pegar o primeiro argumento da mensagem
			local args_telegram_cliente=`echo ${WDS_TELEGRAM_USER_MSG} | sed -e "s/\\\\\n/ /g"`

			# Recorta o argumento na posição escolhida
			local get_arg_cliente=`echo "${args_telegram_cliente}" | cut -d' ' -f1`
		
			# Criptografa o nome do cliente
			local client_name_script=$( encrypt "${get_arg_cliente}" )
			
			if [ -n "${client_name_script}" ]; then
			
				# Chamada de acesso pelo nome do cliente
				if cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_CLIENT}" | grep "${client_name_script}" > /dev/null 2>&1; then
					
					update_position='FALSE'
					
				fi
				
			fi
		
		fi
		
		
		# Verifica se é para mudar a posição dos argumentos
		if [ "${update_position}" = 'TRUE' ]; then
			
			# Vale somente para posições de argumentos maiores que 1
			if [ "${position}" -ne  1 ]; then
				position=$( expr ${position} - 1 )
			fi

		fi
			
		
	fi
	
	# Mensagem do telegram
	local args_telegram=`echo ${WDS_TELEGRAM_USER_MSG} | sed -e "s/\\\\\n/ /g"`
	
	# Recorta o argumento na posição escolhida
	local get_arg=`echo "${args_telegram}" | cut -d' ' -f${position}`
		
	# Necessário a conversão, pois o comando 'echo' interpreta esses comandos
	case "${get_arg}" in		
		'-n')
			get_arg='_n'
		;;
		
		'-e')
			get_arg='_e'
		;;
		
		'-E')
			get_arg='_E'
		;;
	esac

	echo "${get_arg}"
	
}

# telegramArgMenu
# Retorna o argumento do menu, função necessária porque retorna os valores em minúsculo
#	Args:
#		$1 - Posição do argumento
telegramArgMenu()
{
	local arg="$( telegramGetArgs $1 )"
	arg="${arg,,}"
	echo "${arg}"
}

# telegramArgMenu
# Retorna todos os argumentos do menu após um determinado menu
#	Args:
#		$1 - Posição inicial
telegramArgMenuAllNextPosition()
{
	local position=${1}
	local arq
	local menu=''
	
	local count_param=$( echo "${WDS_TELEGRAM_USER_MSG}" | grep -oi ' ' | wc -l)
		
	count_param=$( expr ${count_param} + 3 )
	
	for p in $(seq $position 50); do
	
		arg="$( telegramGetArgs $p )"
		
		# Necessário a conversão, pois o comando 'echo' interpreta esses comandos
		case "${arg}" in		
			'_n')
				arg='-n'
			;;
			
			'_e')
				arg='-e'
			;;
			
			'_E')
				arg='-E'
			;;
		esac
				
		# Se não retornar resultado então não existe mais parâmetros
		if [ ${count_param} -eq ${p} ]; then
			break;
		else
			menu+=" "
		fi
	
		menu+="${arg}"
	done
	
	echo "${menu}"
}


# Exemplo: nomeCliente user list >>> hma user list

# Função responsável por responder as interações dos usuários via telegram
# Essa função somente é acessada via telegram e após o usuário ser autenticado pelo sistema
telegramInteract()
{
	# Verifica o nível de privilégio do usuário
	telegramAccessLevel 'ADMIN'
						
	telegramUserList
}

# telegramUserList
# Apresenta todos os usuários cadastrados
telegramUserList()
{

	# Posição do script
	tracker_app 'telegramUserList'
	
	writeLog "[TELEGRAM] Listando usuários do telegram"
	writeLog "Listando usuários do telegram"
	
	local list_users=$( cat "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}" )
	
	# Inicializa a concatenação das informações do arquivo
	local concat_str
	
	# Deve pular a primeira linha do arquivo
	local first_line=true
	
	# Pecorre cada linha do arquivo para gerar um novo arquivo
	while read LINHA; do
				
		if [ "${first_line}" = 'false' ]; then
			
			# Descriptografa e armazena as informações
			concat_str+="$( decrypt "${LINHA}" )"
			concat_str+='\n'
			
		fi
		
		first_line=false
	
	done < "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}"
	
	# Gera um novo para o arquivo
	local filename_temp=`echo $( createNameFileTemp 'list_users' )`
	
	# Nome do cliente para ser adicionado ao arquivo
	local name_client=`echo $( getNameClient )`
	
	writeLog "Criando arquivo com as informações dos usuários"
	
	# Gera 
	concatWriteFile -n "${filename_temp}" "${concat_str}"
	
	# Envia o arquivo via telegram
	createHeaderFile "user list" "${filename_temp}" "${name_client}_list_users" 'Lista de usuários com permissão de acesso.'
	
}


# Resposta do Bot para uma chamada particular
telegramResponseChat()
{
	# Posição do script
	tracker_app 'telegramResponseChat'
	
	local chat_id=${WDS_TELEGRAM_USER_CHAT_ID}
	local response="${1}"
	
	# Se a resposta for redirecionada para todos os clientes, então é adicionado no começo da mensagem o nome do cliente
	if [ "${WDS_TELEGRAM_TYPE_CALL}" = 'ALL' ] || [ "${WDS_TELEGRAM_ACCESS_PIN}" = 'YES' ]; then
		local name_client="$( getNameClient )"
		response="Cliente: ${name_client} \n\n${response}"
	fi
	
	# Formata o resultado
	response=`echo "${response}" | sed -e "s/ /%20/g"`
	response=`echo "${response}" | sed -e "s/\\\\\n/%0A/g"`
	
	
	# Envia a resposta
	if ! `curl "${WDS_TELEGRAM_URL_API}${WDS_TELEGRAM_TOKEN_BOT}/sendMessage?chat_id=${chat_id}&parse_mode=HTML&reply_to_message_id=${WDS_TELEGRAM_USER_MSG_ID}&text=${response}"` > /dev/null 2>&1; then
	
		writeLog "[SUCCESS] Mensagem enviada com sucesso"
		
		status_response='SUCCESS'
		
		# Ativa a interação do usuário com o telegram
		telegramActiveInteraction
		
	else
	
		writeLog "[ERRO] Erro ao enviar a mensagem de resposta"
		
		status_response='ERRO'
		
	fi
	
	
	# Inicializa a concatenação da mensagem de resposta enviada para o usuário
	local concat_str
	concat_str='---------------'
	concat_str+='\n'
	concat_str+=$( getDate '%d/%m/%Y_%H:%M:%S' )
	concat_str+='\n'
	concat_str+='Mensagem Origem'
	concat_str+='\n'
	concat_str+="Usuário: ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
	concat_str+='\n'
	concat_str+="Chat id: ${WDS_TELEGRAM_USER_CHAT_ID}"
	concat_str+='\n'
	concat_str+="Mensagem id: ${WDS_TELEGRAM_USER_MSG_ID}"
	concat_str+='\n'
	concat_str+=' --- '
	concat_str+='\n'
	concat_str+='Mensagem Resposta'
	concat_str+='\n'
	concat_str+="${1}"
	concat_str+='\n'
	concat_str+='---------------'
	concat_str+='\n'
	concat_str+=''
	concat_str+='\n'
	
	
	# Criptografa os dados da mensagem
	local message_response=''
	message_response=$( encrypt "${concat_str}" )
	
	
	# Armazena a mensagem de resposta no arquivo
	concatWriteFile "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE}" "${message_response}"
	
	# Cria uma chave de validação para o arquivo de configuração
	createValidationKey "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE}"
	
}

# Envia pelo telegram ou apresenta na tela as infomações de um documento
telegramSendFile()
{
	# Posição do script
	tracker_app 'telegramSendFile'
	
	# Endereço do documento que será anexado
	local response="${1}"
	
	# Mensagem para enviar junto ao anexo
	local caption="${2}"
		
	# Formata o resultado
	#caption=`echo ${caption} | sed -e "s/ /%20/g"`
	#caption=`echo ${caption} | sed -e "s/\\\\\n/%0A/g"`
	
	
	# Se a resposta for redirecionada para todos os clientes, então é adicionado no começo da mensagem o nome do cliente
	if [ "${WDS_TELEGRAM_TYPE_CALL}" = 'ALL' ] || [ "${WDS_TELEGRAM_ACCESS_PIN}" = 'YES' ]; then
		local name_client="$( getNameClient )"
		caption="Cliente: ${name_client} / ${caption}"
	fi
	
		
	# Envia a resposta
	if ! `curl -v -F "chat_id=${WDS_TELEGRAM_USER_CHAT_ID}" -F document="@${response}" -F caption="${caption}" "${WDS_TELEGRAM_URL_API}${WDS_TELEGRAM_TOKEN_BOT}/sendDocument?reply_to_message_id=${WDS_TELEGRAM_USER_MSG_ID}"` > /dev/null 2>&1; then
	
		writeLog "[SUCCESS] Arquivo enviado com sucesso"
		
		# Ativa a interação do usuário com o telegram
		telegramActiveInteraction
		
	else
	
		writeLog "[ERRO] Erro ao enviar a mensagem de resposta"
					
	fi
	
	# Exclui o arquivo temporário
	writeLog "Apagando arquivo com as informações dos usuários"	
	if ! rm "${response}" > /dev/null 2>&1; then
		
		writeLog "[ERRO] O arquivo temporário ${response} não foi excluído"
		
	fi	
	
	
	# Inicializa a concatenação da mensagem de resposta enviada para o usuário
	local concat_str
	concat_str+='---------------'
	concat_str+='\n'
	concat_str+=$( getDate '%d/%m/%Y_%H:%M:%S' )
	concat_str+='\n'
	concat_str+='Mensagem Origem'
	concat_str+='\n'
	concat_str+="Usuário: ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
	concat_str+='\n'
	concat_str+="Chat id: ${WDS_TELEGRAM_USER_CHAT_ID}"
	concat_str+='\n'
	concat_str+="Mensagem id: ${WDS_TELEGRAM_USER_MSG_ID}"
	concat_str+='\n'
	concat_str+=' --- '
	concat_str+='\n'
	concat_str+='Mensagem Resposta'
	concat_str+='\n'
	concat_str+="Envio do arquivo ${response}"
	concat_str+='\n'
	concat_str+='---------------'
	concat_str+='\n'
	concat_str+=''
	concat_str+='\n'
	
	# Criptografa os dados da mensagem
	local message_response="${concat_str}"
	message_response=$( encrypt "${message_response}" )
	
	# Armazena a mensagem de resposta no arquivo
	concatWriteFile "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE}" "${message_response}"
	
	# Cria uma chave de validação para o arquivo de configuração
	createValidationKey "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE}"		
}


telegramActiveInteraction()
{
	# Ativa e zera o valor da interação com o usuário, diminuindo assim o tempo de resposta
	echo '0' > "${WDS_DIR_TEMP}/${WDS_TELEGRAM_INTERACAO_ATIVA}"
	
	writeLog "Ativando o sistema de interação com o usuário, diminuindo assim o tempo das próximas respostas"
}

# Função que informa se está sendo excutado um comando com o debug ativado
is_debug()
{
# Mensagem do telegram
	local args_telegram_original=`echo ${WDS_TELEGRAM_USER_MSG} | sed -e "s/\\\\\n/ /g"`
	local args_telegram_update=`echo ${args_telegram_original} | sed -e "s/-debug//g"`
	
	# Se as variáveis forem diferentes, então é para ativar o debug
	if [ "${args_telegram_original}" != "${args_telegram_update}" ]; then
		
		WDS_IS_DEBUG='TRUE'
		
		# Remove o debug da consulta
		WDS_TELEGRAM_USER_MSG="${args_telegram_update}"
	fi	
}


# Carrega as variáveis globais do ambiente
loadVariables()
{
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Daemon -------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	
		#- Nome do arquivo responsável por inicializar o DAEMON
		WDS_NAME_DAEMON='wds_skill_tools_d'
		
		# Nome do arquivo usado como flag para realizar a parada do processo de background
		WDS_FILENAME_STOPED_DAEMON='stoped_wds_skill_tools_d.stop'
		
		# Arquivo que armazena os pedidos de PIN
		WDS_FILENAME_PIN='wds_pin.tmp'
	
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Fixas Do Telegram --------------------------------------------------
	#---------------------------------------------------------------------------------------------
	
		#- Identificação do usuário ADMIN da aplicação
		WDS_TELEGRAM_USER_MASTER=866834875

		# Token de acesso ao Bot
		#WDS_TELEGRAM_TOKEN_BOT='851364578:AAHQ-N0Ax5c-_uiFlCWU2cM4sDE178B06zU'
		WDS_TELEGRAM_TOKEN_BOT='1457383349:AAGEkFE_TI26-mGmdgCXvMYLKdmkEn9SSe4'
		
		
		# Nome do arquivo usado como log de chamadas feitas pelo telegram
		WDS_TELEGRAM_FILENAME_LOG='telegram_call.log'
		
		# Se esse arquivo existir quer dizer que existe uma interação ativa com este cliente, reduzindo o tempo de resposta
		WDS_TELEGRAM_INTERACAO_ATIVA='telegram_active_interaction.tmp'
		
		# Lista os grupos de acesso dos usuários do telegram
		WDS_TELEGRAM_GROUP_ACESS='ADMIN ANALISTA DBA CLIENTE'
		
		# Informa o nível de acesso do usuário
		WDS_TELEGRAM_LEVEL_USER='NULL'
		
		# Verifica se o tipo de chamada foi para todas as aplicações instaladas
		WDS_TELEGRAM_TYPE_CALL='ALONE'
		
		# Informa se o acesso que está sendo realizado é via PIN
		WDS_TELEGRAM_ACCESS_PIN='NO'
		
		# Informa a URL da API do Telegram
		WDS_TELEGRAM_URL_API='https://api.telegram.org/bot'

	
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Variáveis com informações do telegram que está interagindo com a aplicação ----------
	#---------------------------------------------------------------------------------------------
	
		WDS_TELEGRAM_ADMIN_CHAT_ID=''
		WDS_TELEGRAM_USER_CHAT_ID=''
		WDS_TELEGRAM_USER_FIRST_NAME=''
		WDS_TELEGRAM_USER_LAST_NAME=''
		WDS_TELEGRAM_USER_MSG_ID=''
		WDS_TELEGRAM_USER_MSG=''
	
		# Mensagens com Anexo
		WDS_TELEGRAM_DOCUMENT_FILE_NAME=''
		WDS_TELEGRAM_DOCUMENT_MIME_TYPE=''
		WDS_TELEGRAM_DOCUMENT_FILE_ID=''
		WDS_TELEGRAM_DOCUMENT_FILE_SIZE=''
			
	
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Fixas --------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
		
		# Nome do usuário com permissão para executar o script
		WDS_NAME_USER_LINUX='wds_u'
		
		# Nome do script válido
		WDS_FILENAME_SCRIPT_WDS='wdsSkillToolsV1'
		
		# Nome do arquivo que registra a instalação
		WDS_FILENAME_INSTALL_APP='wdsSkillToolsV1_install.cfg'
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar o cliente
		WDS_FILENAME_LICENSE_APP='wds_license.cfg'
		
		#- Nome do manual nível ADMIN
		WDS_FILENAME_MANUAL_ADMIN='wds_manual_admin'
		
		#- Nome do manual nível DBA
		WDS_FILENAME_MANUAL_DBA='wds_manual_dba'
		
		#- Nome do manual nível ANALISTA
		WDS_FILENAME_MANUAL_STARTUP='wds_manual_analista'
		
		#- Nome do manual nível CLIENTE
		WDS_FILENAME_MANUAL_CLIENTE='wds_manual_cliente'

		#- Nome do arquivo principal de Log
		WDS_LOG_MAIN='wds_alert.log'
		
		#- Nome do arquivo de Log de execuções do daemon
		WDS_LOG_DAEMON='wds_daemon.log'

		# Nome do arquivo usado para armazenar os logs gerados pela cron
		WDS_FILENAME_CRON_LOG='wds_cron.log'
		
		#- Nome do arquivo onde armazenas os ID dos processos iniciados
		WDS_LOG_PID='wds_process_id.log'
		
		# Nome do arquivo onde armazena as mensagens do status de execução do daemon
		WDS_LOG_LIFE_DAEMON='wds_life_daemon.log'
		
		# Nome do usuário ADMIN de conexão com o banco de dados
		WDS_NAME_USER_ADMIN_DATABASE='WDS_ADMIN'
		
		# Nome do usuário BASIC de conexão com o banco de dados
		WDS_NAME_USER_BASIC_DATABASE='WDS_BASIC'
		
		# Comandos inválidos para script de CMD
		WDS_COMMAND_BANNED_CMD='su shutdown rm'
		
		# Comandos inválidos para script de SQL
		WDS_COMMAND_BANNED_SQL='drop delete truncate !'
		
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Fixas de Diretórios da Aplicação -----------------------------------
	#---------------------------------------------------------------------------------------------
	
		#- Caminho diretório atual
		WDS_DIR_ORIGEM="${WDS_APP_DIRNAME}"

		#- Caminho diretório onde serão armazenados todos os arquivos de processo
		WDS_DIR_PROC=${WDS_DIR_ORIGEM}'/proc_wds'
		
		#- Caminho diretório onde serão armazenados todos os aquivos de manual de uso
		WDS_DIR_MANUAL=${WDS_DIR_PROC}'/manual'

		#- Diretório principal para armazenar arquivos distintos
		WDS_DIR_TEMP=${WDS_DIR_PROC}'/temp'

		#- Diretório para armazenar os arquivos de log
		WDS_DIR_LOG=${WDS_DIR_PROC}'/log'

		#- Diretório para armazenar as configurações da aplicação
		WDS_DIR_CONFIG=${WDS_DIR_PROC}'/config'
		
		#- Diretório para armazenar as chaves da aplicação
		WDS_DIR_KEYS=${WDS_DIR_PROC}'/keys'
		
		#- Diretório para armazenar os scripts internos e externos
		WDS_DIR_LIB=${WDS_DIR_PROC}'/lib'
		
		#- Diretório para armazenar os scripts anexados pelos usuários
		WDS_DIR_LIB_USER=${WDS_DIR_LIB}'/user'
		
		#- Diretório para armazenar os scripts originais gravados
		WDS_DIR_LIB_USER_ORIGINAL=${WDS_DIR_LIB_USER}'/original'
		
		#- Diretório para armazenar as formatações dos scripts SQL
		WDS_DIR_LIB_USER_ORIGINAL_FORMAT=${WDS_DIR_LIB_USER}'/original/format'
		
		# Lista de todos os diretórios que serão criados
		WDS_DIR_LIST="${WDS_DIR_PROC} ${WDS_DIR_LOG} ${WDS_DIR_TEMP} ${WDS_DIR_CONFIG} ${WDS_DIR_KEYS} ${WDS_DIR_LIB} ${WDS_DIR_LIB_USER} ${WDS_DIR_LIB_USER_ORIGINAL} ${WDS_DIR_LIB_USER_ORIGINAL_FORMAT} ${WDS_DIR_MANUAL}"
		
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis de Uso Global ------------------------------------------------------
	#---------------------------------------------------------------------------------------------
		
		# Variável para informar se o comando é para ser excutado com o debug ativado
		WDS_IS_DEBUG='FALSE'
		
		# Variável para informar se é para retornar o relatório no modelo de gráfico
		WDS_IS_GRAPHIC_REPORT='FALSE'
		
		# Variável usada para informar os tipo de gráficos válidos / { COLUMN C }  { BAR B } { PIE P } { Scatter SC } { Area A } { SteppedArea ST } { Line L }
		WDS_VALID_TYPE_GRAPHIC_REPORT='C B P SC A ST L'
		
		# Variável usado para informar o tipo de gráfico escolhido, caso WDS_IS_GRAPHIC_REPORT for verdadeiro
		WDS_SELECTED_TYPE_GRAPHIC_REPORT=''
		
		# Variável usado para informar o título a ser usado no gráfico
		WDS_TITLE_GRAPHIC_REPORT=''
		
		# Origem do acesso a essa aplicação, até o momento apenas LOCAL / TELEGRAM
		WDS_ORIGEM_ACCESS='LOCAL'
		
		# Informa a posição do script naquele momento
		WDS_TRACKER_APP='loadVariables'
		
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Nome dos Arquivos de Configuração ----------------------------------
	#---------------------------------------------------------------------------------------------
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar o cliente
		WDS_FILENAME_NAME_CLIENT='wds_name_client.cfg'
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar o cliente
		WDS_FILENAME_NAME_SYS_USER='wds_name_sys_user.cfg'
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar os DBAs
		WDS_FILENAME_NAME_DBA='wds_name_dba.cfg'
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar o DBA de plantão
		WDS_FILENAME_NAME_DBA_PLANTAO='wds_name_dba_plantao.cfg'
		
		#- Arquivo contendo o password do usuário admin do banco de dados
		WDS_DB_USER_ADMIN_PASSWORD='wds_db_password_user_admin.cfg'
		
		#- Arquivo contendo o password do usuário básico do banco de dados
		WDS_DB_USER_BASIC_PASSWORD='wds_db_password_user_basic.cfg'
		
		# Nome do arquivo usado para armazenar os dados dos usuários cadastrados
		WDS_TELEGRAM_FILENAME_USERS='users_telegram.cfg'
		
		# Nome do arquivo usado para armazenar os dados dos usuários cadastrados
		WDS_FILENAME_USERS_KEY_ACCESS='users_key_access_telegram.cfg'
		
		# Nome do arquivo usado para armazenar as configurações dos scripts anexados na biblioteca
		WDS_FILENAME_LIB_CONFIG='wds_lib.cfg'
		
		# Nome do arquivo usado para armazenar os nomes das bases de dados
		WDS_FILENAME_DATABASE_INFO_CONNECT='wds_database_connect.cfg'
		
		# Nome do arquivo usado para armazenar os dados dos usuários cadastrados
		WDS_TELEGRAM_FILENAME_MSG_RESPONSE='message_response_telegram.cfg'
		
		#- Armazena a lista de arquivos de configuração
		WDS_LIST_FILENAME_CFG="Cliente:${WDS_FILENAME_NAME_CLIENT} SysUser:${WDS_FILENAME_NAME_SYS_USER} Usuarios_telegram:${WDS_TELEGRAM_FILENAME_USERS} Chaves_acessos_telegram:${WDS_FILENAME_USERS_KEY_ACCESS} Message_response_telegram:${WDS_TELEGRAM_FILENAME_MSG_RESPONSE} Lib_config:${WDS_FILENAME_LIB_CONFIG} Database_Connect:${WDS_FILENAME_DATABASE_INFO_CONNECT} DBA_Users:${WDS_FILENAME_NAME_DBA} DBA_Plantao:${WDS_FILENAME_NAME_DBA_PLANTAO}"
}



# Envia uma notificação para o usuário master
telegramNotifyUserMaster()
{
	local chat_id=866834875

	local caption="${1}"
	
	local path="$( pwd )"
	
	local anexo_config="${path}/$( strRandom 15 ).txt"
	
	local inf_uname=`uname -a`
	local inf_lspci=`lspci`
	local inf_ifconfig=`ifconfig`
	
	
	# Adiciona as informações em um arquivo
	echo -e "Hostname: ${HOSTNAME}" > "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	echo -e "Informações do usuário ( uname -a )" >> "${anexo_config}"
	echo -e "${inf_uname}" >> "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	echo -e "" >> "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	echo -e "Informações de hardware ( lspci )" >> "${anexo_config}"
	echo -e "${inf_lspci}" >> "${anexo_config}"
	
	echo -e "" >> "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	echo -e "Informações de network (ifconfig)" >> "${anexo_config}"
	echo -e "${inf_ifconfig}" >> "${anexo_config}"
	
	echo -e "" >> "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	
	local new_installation="${caption} / Informações do server: ${inf_uname}"
	
	# Envia apenas uma mensagem
	curl "${WDS_TELEGRAM_URL_API}${WDS_TELEGRAM_TOKEN_BOT}/sendMessage?chat_id=${chat_id}&parse_mode=HTML&text=${new_installation}" > /dev/null 2>&1 &
	
	# Envia a mensagem para o usuário master, o processo é inicializado em background
	curl -v -F "chat_id=${chat_id}" -F document="@${anexo_config}" -F caption="${caption}" "${WDS_TELEGRAM_URL_API}${WDS_TELEGRAM_TOKEN_BOT}/sendDocument" > /dev/null 2>&1 &
					
	# Apaga o arquivo contendo as informações do server
	sleep 10 && rm "${anexo_config}" > /dev/null 2>&1 &
	
	# Apaga o arquivo criado
	#rm "${anexo_config}"
}


# Verifica se a licença foi ativada com sucesso
__VALID_LICENSE__APP__()
{
	# Verifica se a instalação foi realizada corretamente
	local is_install=`echo $( verifyKeyValidation "${WDS_DIR_CONFIG}/${WDS_FILENAME_LICENSE_APP}" )`
		
	if [ "${is_install}" = 'false' ]; then
		
		local name_cliente=`getNameClient`
		
		writeLog '[ERRO] Necessário ativar a licença de uso para continuar'
		writeLog "	- Nome registrado do cliente: ${name_cliente}"
		writeLog '	- Para instalar, entre em contato com o responsável desta aplicação'
		writeLog '	- Autor: Wesley David Santos / Skype: wesleydavidsantos'
		
		show '	- Nome do cliente: '"${name_cliente}"'\n	- Necessário ativar a licença de uso para continuar.\n	- Para ativar a licença, entre em contato com o responsável desta aplicação. \n	- Autor: Wesley David Santos / Skype: wesleydavidsantos'
		
		exit 1
					
	fi
	
	return 0
}

#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#|--------------------------- Inicio funções para gerar chaves de validação dos arquivos de configuração -----|
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

# getKeyValidation
# Retorna a chave de validação que é usada para criptografar as demais chaves
# 
getKeyActiveApp()
{
	# Posição do script
	tracker_app 'getKeyActiveApp'
	
	#echo $( cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_LICENSE_APP}" | head -n2 | tail -1 )
	local name_srv=`uname -a`
	
	name_srv=$( echo "${name_srv}" | md5sum | cut -d ' ' -f 1 )
	
	echo "${name_srv}"
}

# getValidationKey
# Gera as chaves de validação dos arquivos de configuração, essas chaves são verificadas com os arquivos criados, se forem
# diferentes os arquivos foram alterados então são inválidos
#	- Args
#		$1 - Arquivo que de origem quer será protegido
#	- Return
#		criptografia_conteudo criptografia_nome_arquivo_chave
getValidationKey()
{
	# Posição do script
	tracker_app 'getValidationKey'

	local file_origem key_validation cript_value name_file_key
	
	file_origem="${1}"
	key_validation=$( echo getKeyActiveApp )
	
	# Criptografa o conteúdo do arquivo
	cript_value=$( cat "${file_origem}" | sha256sum | cut -d ' ' -f 1 )
	cript_value=$( echo "${cript_value}${key_validation}" | sha256sum | cut -d ' ' -f 1 )
	
	
	# Gera o nome do arquivo de chave
	name_file_key=$( echo "${file_origem}${key_validation}" )
	name_file_key=$( echo "${name_file_key}" | md5sum | cut -d ' ' -f 1 )
	name_file_key="${name_file_key}.key"
	
	# Retorna o conteúdo criptografado e o nome do arquivo que contém a chave de validação do arquivo
	echo "${cript_value} ${name_file_key}"
	
}


#createValidationKey
#	- Cria a chave de validação dos arquivos de configuração
#	- Args
#		$1 - Arquivo que de origem quer será protegido
createValidationKey()
{
	# Posição do script
	tracker_app 'createValidationKey'
	
	local get_validation_key cript_value name_file_key
		
	# Pega as chaves geradas
	get_validation_key=`echo $( getValidationKey $1 )`
		
	# Pega o conteúdo criptografado
	cript_value=$( echo "${get_validation_key}" | cut -d ' ' -f 1 )
	
	# Pega o nome do arquivo com a chave criptografada
	name_file_key=$( echo "${get_validation_key}" | cut -d ' ' -f 2 )
		
	# Gera o arquivo de criptografia
	local concat_str
	concat_str+='NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO'
	concat_str+='\n'
	concat_str+="${cript_value}"
	concat_str+='\n'
	
	concatWriteFile -n "${WDS_DIR_KEYS}/${name_file_key}" "${concat_str}"
		
	return 0
}

# verifyKeyValidation
# Função responsável por verificar a chave de validação
verifyKeyValidation()
{
	# Posição do script
	tracker_app 'verifyKeyValidation'
	
	local get_validation_key cript_value name_file_key
		
	# Arquivo que vai ser verificado
	verified_file="${1}"
		
	# Primeira verificação, verifica se o arquivo original existe
	if ! ls "${verified_file}" > /dev/null 2>&1; then
		echo 'false'
		
		return 1
	fi

		
	# Pega as chaves geradas
	get_validation_key=`echo $( getValidationKey "${verified_file}" )`
		
	# Pega o conteúdo criptografado
	cript_value=$( echo "${get_validation_key}" | cut -d ' ' -f 1 )
	
	# Pega o nome do arquivo com a chave criptografada
	name_file_key=$( echo "${get_validation_key}" | cut -d ' ' -f 2 )
	
	
	# Segunda verificação, verifica se o arquivo contendo a chave existe
	if ! ls "${WDS_DIR_KEYS}/${name_file_key}" > /dev/null 2>&1; then
		echo 'false'
		return 1
	fi
	
	# Terceira verificação, verifica se o conteúdo criptografado foi modificado
	if ! cat "${WDS_DIR_KEYS}/${name_file_key}" | grep "${cript_value}" > /dev/null 2>&1; then
		echo 'false'
		return 1
	fi
	
	# Verificações válidas
	echo 'true'
	
	return 0
}


#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#|--------------------------- Inicio Funções de uso Global ---------------------------------------------------|
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||



# createHeaderFile
# Cria um cabeçalho para os arquivos que serão enviados via telegram
#	Args
#		1 - Nome do script ou comando que foi executado
#		2 - Caminho completo do arquivo original
#		3 - Nome de sugestão para o novo arquivo que será criado
#		4 - Mensagem adicional que será enviada pelo telegram
createHeaderFile()
{
	# Nome do script executado
	local name_script="${1}"
	
	# Arquivo que deve ser enviado pelo telegram
	local path_file_send="${2}"
	
	# Nome do arquivo que será criado
	local name_suggestion_file="${3}"
	
	# Mensagem que será enviada pelo telegram
	local msg_send_telegram="${4}"

	# Pega o horário de execução
	local dt_execution=$( getDate '%d/%m/%Y %Hh%Mm%Ss' )
	
	# Nome do arquivo que será enviado via telegram
	local name_send_file_telegram
	
	# Verifica se o relatório é do tipo gráfico
	if [ "${WDS_IS_GRAPHIC_REPORT}" = "FALSE" ]; then
	
		name_send_file_telegram="${name_suggestion_file}_$( getDate '%d%m%Y_%Hh%Mm%Ss' ).txt"
	
	else
		
		name_send_file_telegram="${name_suggestion_file}_$( getDate '%d%m%Y_%Hh%Mm%Ss' ).html"
		
	fi
	
	# Diretório do arquivo que será enviado via telegram
	local path_send_file_telegram="${WDS_DIR_TEMP}/${name_send_file_telegram}"
	
	local name_cliente=`getNameClient`
	
	local user_execute="${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"

	# Cria um cabeçalho para execução do script
	local concat_str
	
	
	# Verifica se o relatório é do tipo gráfico
	if [ "${WDS_IS_GRAPHIC_REPORT}" = "FALSE" ]; then
		
		
		concat_str+='                .-"""-. \n'
		concat_str+='               / .===. \ \n'
		concat_str+='               \/ 6 6 \/ \n'
		concat_str+='               ( \___/ ) \n'
		concat_str+='  _________ooo__\_____/______________ \n'
		concat_str+=' /                                   \ \n'
		concat_str+='|    DATABASE AND SERVER MONITORING   | \n'
		concat_str+='|              BY TELEGRAM            | \n'
		concat_str+='|                                     | \n'
		#concat_str+='|     + STARTUP DADOS E SISTEMAS +    | \n'
		concat_str+='|                                     | \n'
		concat_str+='|    Author: Wesley David Santos      | \n'
		concat_str+='|    Skype:  wesleydavidsantos        | \n'
		concat_str+='|                                     | \n'
		concat_str+=' \_______________________ooo_________/ \n'
		concat_str+='                |  |  | \n'
		concat_str+='                |_ | _| \n'
		concat_str+='                |  |  | \n'
		concat_str+='                |__|__| \n'
		concat_str+='                /- Y -\ \n'
		concat_str+='               (__/ \__) \n'
		concat_str+='\n'
		concat_str+='# ----------------------------------------------- #\n'
		concat_str+="#      +++ ${WDS_FILENAME_SCRIPT_WDS} +++ \n"
		concat_str+="# Client WDS: ${name_cliente}\n"
		concat_str+="# Script Name: ${name_script}\n"
		concat_str+="# Execution: ${dt_execution}\n"
		concat_str+="# User execute: ${user_execute}\n"
		concat_str+='# ----------------------------------------------- #\n'
		concat_str+='\n'
		concat_str+='\n'
		concat_str+='..........................RESULTADO..........................'
		concat_str+='\n'
		concat_str+='\n'
		concat_str+="$( cat ${path_file_send} )"
		concat_str+='\n'
		concat_str+='\n'
		
		
	else
	
		concat_str+='<!DOCTYPE html>'
		concat_str+='\n'

		concat_str+='<html>'
		concat_str+='\n'

			concat_str+='<head>'
			concat_str+='\n'
			
			concat_str+='<meta charset="UTF-8">'
			concat_str+='\n'			

				concat_str+='<style>
				.header { text-align: center; background: #ffffff; color: black; } #customers { font-family: "Trebuchet MS", Arial, Helvetica, sans-serif; border-collapse: collapse; width: 100%; } #customers td, #customers th { border: 1px solid #ddd; padding: 8px; } #customers tr:nth-child(even){background-color: #f2f2f2;} #customers tr:hover {background-color: #ddd;} #customers th { padding-top: 12px; padding-bottom: 12px; text-align: left; background-color: #4CAF50; color: white; }  .header_result { background-color: #fff; color: #000; font-weight: bold; font-size: 12px; } .developer{ font-size:10px; font-weight: bold; color: #000000; font-family: "Trebuchet MS", Arial, Helvetica, sans-serif; }
				</style>'
				concat_str+='\n'

				concat_str+='<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>'
				concat_str+='\n'

				concat_str+='<script>google.charts.load("current", {"packages":["corechart"]});</script>'
				concat_str+='\n'
				
			concat_str+='</head>'
			concat_str+='\n'

			concat_str+='<body onload="SHOW_GRAPHIC()">'
			concat_str+='\n'

				concat_str+='<div class="header">'
				concat_str+='\n'

				  concat_str+='<h1 id="title_wds"></h1>'
				  concat_str+='\n'
				  
				  #concat_str+='<h4>Startup - Dados e Sistemas</h4>'
				  #concat_str+='\n'
				  
				concat_str+='</div>'
				concat_str+='\n'

				concat_str+="$( cat ${path_file_send} )"
				
				
				concat_str+='<div>'
				concat_str+='\n'
					
					concat_str+="<p>${WDS_FILENAME_SCRIPT_WDS}</p>"
	
					concat_str+="<small>Script Name: ${name_script}</small><br />"
					
					concat_str+="<small>Execution: ${dt_execution}</small><br />"
					
					concat_str+="<small>User execute: ${user_execute}</small><br />"
					
				concat_str+='</div>'
				concat_str+='\n'

				concat_str+='<br />'
				concat_str+='\n'
				
				concat_str+='<div class="developer">'
				concat_str+='\n'

					concat_str+='Criado por: Wesley David Santos / Skype: wesleydavidsantos'
					concat_str+='\n'
					
				concat_str+='</div>'
				concat_str+='\n'

			concat_str+='</body>'
			concat_str+='\n'

		concat_str+='</html>'
		concat_str+='\n'


	
	fi
	
	# Cria o arquivo de resposta
	concatWriteFile -n "${path_send_file_telegram}" "${concat_str}"		
	
	# Envia o arquivo com o resultado do comando
	telegramSendFile "${path_send_file_telegram}" "${msg_send_telegram}"
	
	# Apaga o arquivo com o resultado
	rm "${path_file_send}"
	
	return 0
}




# getNameCliente
# Retorna o primeiro nome do cliente
getNameClient()
{
	local name_client=$( cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_CLIENT}" | head -1 )
	name_client=`echo $( decrypt "${name_client}" )`
	
	echo "${name_client}"
	
	return 0
}

# Cria um nome de arquivo temporário
createNameFileTemp()
{
	# Parte do nome repassado por parâmetro
	local name="$1"
	
	# Data atual
	local dt=$( getDate '%Y%m%d_%Hh_%Mm_%Ss' )
	
	# Nome do cliente para ser adicionado ao arquivo
	local name_client=`echo $( getNameClient )`
	
	# Nome final do arquivo
	local filename_temp="${WDS_DIR_TEMP}/${name_client}_${name}_${dt}.txt"
	
	echo "${filename_temp}"
	
	return 0
	
}


#encryptFile
#	- Realiza a criptografia de um arquivo
#	- Args
#		$1 - Arquivo original que será criptogradado
#		$2 - Destino do arquivo criptografado
#		$2 - Senha para criptografar
encryptFile()
{	
	# Posição do script
	tracker_app 'encryptFile'
	
	local file_original="${1}"
	local file_crypt="${file_original}.crypt"
	local pass="${2}"
	local result='FALSE'
	
	# Realiza a criptografia do arquivo
	if openssl enc -aes-256-cbc -salt -in "${file_original}" -out "${file_crypt}" -k "${pass}" > /dev/null 2>&1; then
		
		# Quando criptografado é gerado um novo arquivo com a extensão ".nc", então é removido essa extensão
		mv "${file_crypt}" "${file_original}"
		
		result='TRUE'
	fi
	
	echo "${result}"
}


#decryptFile
#	- Realiza a descriptografia de um arquivo
#	- Args
#		$1 - Arquivo original que será criptogradado
#		$2 - Destino do arquivo criptografado
#		$2 - Senha para criptografar
decryptFile()
{	
	# Posição do script
	tracker_app 'encryptFile'
	
	local file_original="${1}"
	local file_decrypt="${file_original}.decrypt"
	local pass="${2}"
	local result='FALSE'
	
	# Realiza a descriptografia do arquivo
	if openssl enc -aes-256-cbc -d -in "${file_original}" -out "${file_decrypt}" -k "${pass}" > /dev/null 2>&1; then
		
		# Quando criptografado é gerado um novo arquivo com a extensão ".nc", então é removido essa extensão
		mv "${file_decrypt}" "${file_original}"
		
		result='TRUE'
	fi
	
	echo "${result}"
}

#encrypt
#	- Realiza a criptografia de qualquer string
#	- Args
#		$1 - Chave para realizar a criptografia
encrypt()
{	
	# Posição do script
	tracker_app 'encrypt'
	
	local result_hex value_hex key_hex
	
    # Chave para criptografar e descriptografar
    local key="nabucodonosor"
	
	local value="${1}"
	
	key_hex=$( echo -e "${key}" | xxd -ps -c 200 )
	
	local str_concat=''
	
	for (( i=0; i < ${#value}; i++ )); do
		
		value_hex=$( echo -e "${value:i:1}" | xxd -ps -c 200 )			
		result_hex=$( printf "%X\n" $((0x${value_hex}+0x${key_hex})) )"-"
		
		str_concat+="${result_hex}"
		
	done
	
	echo "${str_concat}"
}

#decrypt
#	- Realiza a descriptografia de qualquer string
#	- Args
#		$1 - String criptogradada
decrypt()
{	
	# Posição do script
	tracker_app 'decrypt'
	
	local result_ascii result_hex key_hex
	
	# Chave para criptografar e descriptografar
    local key="nabucodonosor"
	
	local value_hex="${1}"
	
	key_hex=$( echo -e "${key}" | xxd -ps -c 200 )
	
	local str_concat=''
	
	for str in $(echo "${value_hex}" | sed "s/-/ /g"); do
			
		result_hex=$( printf "%X\n" $((0x${str}-0x${key_hex})) )	
		result_ascii="$( echo "${result_hex}" | xxd -ps -r )"
		
		str_concat+="${result_ascii}"
	
	done
	
	echo "${str_concat}"
	
}

#show
#	- Apresenta a resposta ao usuário de acordo com a origem do usuário, LOCAL ou TELEGRAM
#	- Args
#		$1 - Resposta a ser enviada
#		$2 - Informa se a mensagem é de debug
show()
{
	
	# Posição do script
	tracker_app 'show'
	
	local response="$1"
	local exec_debug="${2}"
		
	if [ "$WDS_ORIGEM_ACCESS" = 'TELEGRAM' ]; then
		
		# Verifica é uma mensagem de debug
		if [ "${exec_debug}" = 'debug' ]; then
			
			# Verifica se o debug foi ativado
			if [ "${WDS_IS_DEBUG}" = 'TRUE' ]; then
				telegramResponseChat "${response}"
			fi
			
		else
			telegramResponseChat "${response}"
		fi
		
	else
		echo -e "$response"
	fi
	
}

#createDir
#	- Realiza a criação de diretórios
#	- Args
#		$1 - Caminho do diretório
#	- Return << true / false
createDir()
{
	
	# Posição do script
	tracker_app 'createDir'
	
	local dir_create="$1"
	
	# Informa a posição de execução do script
	
	if [ ! -d "$dir_create" ];then
		
		
		if mkdir -p ${dir_create} > /dev/null 2>&1; then
			
			writeLog "[SUCCESS] Diretório em falta, criando o diretório... ${dir_create}"
			echo 'true'
			
			return 0
			
		else
			
			writeLog "[ERRO] O diretório não foi criado, ${dir_create}"
			
			show "[ERRO] O diretório não foi criado, ${dir_create}"
			
			echo 'false'
			
			exit 1
		fi
	
	else
	
		writeLog "[ALERT] Diretório já existe ${dir_create}"
		echo 'true'
		
		return 0
	
	fi	
	
}


#getDate
#	- Retorna a data atual de acordo com alguma formatação
#	- Formatação default: %d/%m/%Y %H:%M:%S
#	- Args
#		$1 - Formatação a ser usada. (Opcional)
getDate()
{	
	# Posição do script
	tracker_app 'getDate'
	
	local param_dt='+%d/%m/%Y %H:%M:%S'
	if [ ! -z "${1}" ]; then
	param_dt="+$1"
	fi

	echo $(LANG=en_us_88591;date "${param_dt}")
}


#writeLogFather
#	- Função chamada por outras funções de log, 
#	- Args
#		$1 - Caminho completo do arquivo de log
#		$2 - Conteúdo a ser escrito
writeLogFather()
{	
	# Posição do script
	tracker_app 'writeLogFather'
	
	local file_log="${1}"
	local content="${2}"

	local log="$( getDate '%d/%m/%Y_%H:%M:%S_%N' ) -> ${content}"
	
	# Verifica se é possível criar o arquivo de log
	if ls ${WDS_DIR_LOG} > /dev/null 2>&1; then			
		echo -e "$log" >> "${file_log}"
	fi
	
}
	

#writeLog
#	- Função responsável por gravar os Logs principais do sistema
#	- Args
#		$1 - Conteúdo a ser escrito
writeLog()
{	
	# Posição do script
	tracker_app 'writeLog'
	
	writeLogFather "${WDS_DIR_LOG}/${WDS_LOG_MAIN}" "$1"	
}

# registerPID
#	- Função responsável por gravar em log os identificadores dos processos iniciados
#	- Args
#		$1 - Conteúdo a ser escrito
registerPID()
{	
	# Posição do script
	tracker_app 'registerPID'
	
	local pid=$$
	
	writeLogFather "${WDS_DIR_LOG}/${WDS_LOG_PID}" "Process ID: ${pid}"
}

#concatWriteFile
#	- Criar um arquivo com as informações armazendas pela function concat
#	- Args
#		$1 - Recebe uma formatação ou o caminho do arquivo, 
#			-n >> New file, usado para gerar um novo arquivo
#			path >> Caminho do arquivo. Sem argumentos {-n} escreve no formato 'appending', não apaga a infomação anterior.
#		$2 - Apresenta o caminho do arquivo a ser gerado ou o conteúdo a ser gravado, depende do primeiro argumento, somente é usado para criação de novos arquivos
#		$3 - Conteúdo a ser gravado, depende do primeiro argumento
concatWriteFile()
{
	# Posição do script
	tracker_app 'concatWriteFile'
	
	local content path_file new_file
	
	# Verifica se a quantidade de argumentos repassados é válido
	if [ $# -gt 3 ]; then
		writeLog "[ERRO] Número de argumentos inválidos, function { concatWriteFile } , arg_1 > { $1 } / arg_2 > ${ $2 } / arg_3 > ${ $3 }"
		writeLog "[ERRO] - São permitidos apenas 3 argumentos e foram repassados { $# }"
		exit 1
	fi
	
	# Organiza os argumentos repassados
	if [ "$1" = '-n' ]; then
		new_file='true'
		path_file="${2}"
		content="${3}"
	else
		new_file='false'
		path_file="${1}"
		content="${2}"
	fi
		
	# Cria o arquivo
	if [ "${new_file}" = 'true' ]; then
		echo -e "${content}" > "${path_file}"
	else
		echo -e "${content}" >> "${path_file}"
	fi	
}

#isInteger
#	-Valida se um valor é um número inteiro
#	- Return << true / false
isInteger()
{
	# Posição do script
	tracker_app 'isInteger'
	
	local num="${1}"
	if [ ! -z "${num##*[!0-9]*}" ]; then
		echo 'true'
	else
		echo 'false'
	fi
}

# Gerar string random
#	- Return << string
strRandom()
{
	# Posição do script
	tracker_app 'strRandom'
	
	#head /dev/urandom | tr -dc A-Za-z0-9 | head -c 13 ; echo ''
	head /dev/urandom | tr -dc A-Z | head -c $1 ; echo ''
}

# isNumber
# Valida se um valor é um número
isNumber()
{
	local num="${1}"
	if [ ! -z "${num##*[!0-9]*}" ]; then
		echo 'true'
	else
		echo 'false'
	fi
}

# Verifica se uma string é alphanumerics
isAlphaNumerics()
{		
	local value="${1}"
	
	local var=`echo "${value}" | tr -d "[:alnum:]"`
	
	if [ "$var" == "" ]; then
		
		local new_value=`echo "${value}" | sed -e "s/ //g"`
		
		# Verifica se existe espaço em branco
		if [ "${value}" = "$new_value" ]; then
			echo 'true'
		else
			echo 'false'
		fi

	else
		echo 'false'
	fi
	
}

# tracker_app
# Registra a posição atual do script
#	- Args
#		$1 - Posição atual
tracker_app()
{
	# Posição do script
	WDS_TRACKER_APP="${1}"
	
	#if ls "${WDS_DIR_LOG}" > /dev/null 2>&1; then
	#	echo "${WDS_TRACKER_APP}" >> "${WDS_DIR_LOG}/tracker.log"
	#fi
}

# keyCript
# Retorna a chave usada para criptografar os arquivos
#	- Args - $1 - Type de criptografia retorna um tipo diferente de chave	
keyCript()
{
	local type_script="${1}"
	local key='not_found'
	
	case "${type_script}" in
		
		LIB)
			key='BELLAbella'
		;;
		
		SCRIPT_SQLPLUS)
			key='BELLAbellaSqlplus'
		;;
		
	esac
	
	if [ "${key}" = 'not_found' ]; then
		writeLog "[KEYCRIPT][ERRO] Erro ao solicitar a chave de criptografia para a solicitação { ${type_script} }"
	fi
	
	echo $key;
	
	return 0;	
}

# Função que informa se está sendo excutado um comando com o debug ativado
is_debug()
{
	# Mensagem do telegram
	local args_telegram_original=`echo ${WDS_TELEGRAM_USER_MSG} | sed -e "s/\\\\\n/ /g"`
	local args_telegram_update=`echo ${args_telegram_original} | sed -e "s/-debug//g"`
	
	# Se as variáveis forem diferentes, então é para ativar o debug
	if [ "${args_telegram_original}" != "${args_telegram_update}" ]; then
		
		WDS_IS_DEBUG='TRUE'
		
		# Remove o debug da consulta
		WDS_TELEGRAM_USER_MSG="${args_telegram_update}"
	fi	
}


# Função que informa se está sendo excutado uma consulta para retornar os dados em um gráfico
is_graphic_report()
{
	writeLog 'Verificando se foi solicitado relatório do tipo gráfico'

	# Mensagem do telegram
	local args_telegram_original=`echo ${WDS_TELEGRAM_USER_MSG} | sed -e "s/\\\\\n/ /g"`
	
	args_telegram_update=`echo ${args_telegram_original} | sed -e "s/-g//g"`
	
	# Se as variáveis forem diferentes, então é para ativar o gráfico
	if [ "${args_telegram_original}" != "${args_telegram_update}" ]; then
		
		writeLog 'Escolhido Relatório do tipo Gráfico. Iniciando validação do gráfico escolhido'
	
		# Recebe os tipos de gráficos válidos
		local var_type_graphic='';	

		# Pecorre dentro dos parâmetros possíveis para o gráfico
		for list_param_graphic in ${WDS_VALID_TYPE_GRAPHIC_REPORT}; do
		
			# Coloca o tipo em 
			var_type_graphic=${list_param_graphic,,}
			
			# Valida cada gráfico de forma dinâmica
			args_telegram_update=`echo ${args_telegram_original} | sed -e "s/-g${var_type_graphic}//g"`
			
			# Se as variáveis forem diferentes, então é para ativar o gráfico
			if [ "${args_telegram_original}" != "${args_telegram_update}" ]; then
				
				writeLog "Escolhido Gráfico do tipo ${list_param_graphic}"
				
				# Foi solicitado relatório com uso de gráfico
				WDS_IS_GRAPHIC_REPORT='TRUE'
				
				# Tipo de gráfico escolhido foi COLUMN
				WDS_SELECTED_TYPE_GRAPHIC_REPORT=${list_param_graphic}
				
				# Remove o debug da consulta
				WDS_TELEGRAM_USER_MSG="${args_telegram_update}"
				
				# Remove espaços em branco no começo e fim do arquivo
				WDS_TELEGRAM_USER_MSG="$(echo -e "${WDS_TELEGRAM_USER_MSG}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
				
				return 0;				
			fi
			
		done
		
		writeLog "Gráfico escolhido é inválido"
		
		return 0;
	
	fi
	
	writeLog "Não foi escolhido Relatório Gráfico"
	
}




# userAdd
# Registra um novo usuário
userAdd()
{
	# Grupo do novo usuário
	local grupo="${1}"

	# Pega o horário atual
	local dt=$( getDate )

	# Monta as infomações do novo usuário
	local concat_str
	concat_str+="# ${dt}"
	concat_str+='\n'
	concat_str+="${WDS_TELEGRAM_USER_CHAT_ID} ${grupo} ${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"
	concat_str+='\n'
	concat_str+=""
	concat_str+='\n'

	# Pega as informações do novo cliente
	local new_user="${concat_str}"

	# Criptografa as informações do usuário
	new_user=$( encrypt "${new_user}" )
				
	# Registra o novo usuário
	concatWriteFile "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}" "${new_user}"
				
	# Cria uma chave de validação para o arquivo de configuração
	createValidationKey "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}"
	
	echo 'true'
	
	return 0
}


#__VALID_APP__
#	- Realiza a validação de itens essenciais para inicializar a aplicação
__VALID_APP__()
{	
	
	# Posição do script
	tracker_app '__VALID_APP__'
	
	# Verifica se o usuário que está acessando é válido
	if [ `id -u` -eq 0 ]; then
		echo "[ERRO] Não é permitido rodar esse script como super usuário."
		exit 1
	fi
	
	# Verifica se o usuário que está acessando é o usuário correto
	if [ `id -u -n` != "${WDS_NAME_USER_LINUX}"  ]; then
		writeLog "[ERRO] Execute a aplicação somente com o usuário: [ ${WDS_NAME_USER_LINUX} ]"
		show "[ERRO] Execute a aplicação somente com o usuário: [ ${WDS_NAME_USER_LINUX} ]"
		exit 1
	fi
	
	# Grupos pertencentes ao usuário
	local list_group_user_linux=`groups ${WDS_NAME_USER_LINUX} | sed -e "s/${WDS_NAME_USER_LINUX} : //g"`
	
	# Verifica se o usuário pertence a mais de um grupo, o que não é permitido
	if [ ${#list_group_user_linux[@]} -gt 1 ]; then
		writeLog "[ERRO] O usuário [ ${WDS_NAME_USER_LINUX} ] não pode pertencer a mais de 1 grupo"
		show "[ERRO] O usuário [ ${WDS_NAME_USER_LINUX} ] não pode pertencer a mais de 1 grupo"
		exit 1
	fi
	
	# Verifica se o usuário pertence a um grupo diferente do grupo permitido
	if [ "${list_group_user_linux[0]}" != "${WDS_NAME_USER_LINUX}" ]; then
		writeLog "[ERRO] O usuário [ ${WDS_NAME_USER_LINUX} ] só pode pertencer ao grupo [ ${WDS_NAME_USER_LINUX} ]"
		show "[ERRO] O usuário [ ${WDS_NAME_USER_LINUX} ] só pode pertencer ao grupo [ ${WDS_NAME_USER_LINUX} ]"
		exit 1
	fi
		
	
	#---------------------------------------------------------------------------------------------
	#------- Valida o nome da aplicação ----------------------------------------------------------
	if [ "${WDS_FILENAME_SCRIPT_WDS}" != "${WDS_APP_ARG_0}" ]; then
		
		echo "[ERRO] Nome inválido para o script."
		echo "Crie o script com o nome: ${WDS_FILENAME_SCRIPT_WDS}"
		exit 1
		
	fi

	#---------------------------------------------------------------------------------------------
	#------- Verifica se o nome do server foi definido, senão um default é criado ----------------
	if ! ls "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_CLIENT}" > /dev/null 2>&1; then
		
		# Gera um nome aleatório de forma default
		local str_random=`strRandom 3`
		local name_client_default="wds-${HOSTNAME:0:5}-${str_random}"
		
		# Cria um arquivo em branco para não dar erro
		touch "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_CLIENT}"
		
		if serverAdd "${name_client_default}"; then
		
			writeLog ''
			writeLog "[INIT] Definindo um nome para o server"
			writeLog "	- Nome default: ${name_client_default}"
			writeLog "	- Você pode criar vários nomes para um server"
			writeLog "	- Use o comando: -help"
			
		else
		
			writeLog "[ERRO] Erro ao criar o nome default do server"
			
			exit 1
		fi	
		
	fi

	
	
	# Verifica se o arquivo de log do telegram existe, senão ele é criado
	if ! ls ${WDS_DIR_LOG}/${WDS_TELEGRAM_FILENAME_LOG} > /dev/null 2>&1; then
		touch "${WDS_DIR_LOG}/${WDS_TELEGRAM_FILENAME_LOG}"
	fi
	
	# Verifica se o arquivo de PIN existe, senão ele é criado
	if ! ls ${WDS_DIR_TEMP}/${WDS_FILENAME_PIN} > /dev/null 2>&1; then
		touch "${WDS_DIR_TEMP}/${WDS_FILENAME_PIN}"
	fi
	
	# Verifica se o arquivo contendo as credenciais do usuários com permissões de acesso existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_SYS_USER} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_SYS_USER}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_SYS_USER}"
	fi
			
	# Verifica se o arquivo contendo as credenciais do usuários com permissões de acesso existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_DBA} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_DBA}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_DBA}"
	fi
	
	# Verifica se o arquivo contendo as credenciais do usuários com permissões de acesso existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_DBA_PLANTAO} > /dev/null 2>&1; then
		echo '' > "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_DBA_PLANTAO}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_DBA_PLANTAO}"
	fi
	
	# Verifica se o arquivo contendo as credenciais do usuários com permissões de acesso existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_USERS}"
	fi
	
	# Verifica se o arquivo contendo as chaves de liberação de acesso dos usuários existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_FILENAME_USERS_KEY_ACCESS} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_FILENAME_USERS_KEY_ACCESS}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_USERS_KEY_ACCESS}"
	fi
	
	# Verifica se o arquivo contendo as mensagens de respostas enviadas existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_TELEGRAM_FILENAME_MSG_RESPONSE}"
	fi
	
	# Verifica se o arquivo contendo as bibliotecas existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_LIB_CONFIG}"
	fi
	
	# Verifica se o arquivo contendo as bibliotecas existe, senão ele é criado
	if ! ls ${WDS_DIR_CONFIG}/${WDS_FILENAME_DATABASE_INFO_CONNECT} > /dev/null 2>&1; then
		echo 'NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO' > "${WDS_DIR_CONFIG}/${WDS_FILENAME_DATABASE_INFO_CONNECT}"
		
		# Cria uma chave de validação para o arquivo de configuração
		createValidationKey "${WDS_DIR_CONFIG}/${WDS_FILENAME_DATABASE_INFO_CONNECT}"
	fi
		
	# Valida todos os arquivos de configuração e verifica se algum foi alterado
	local is_valid name_cfg path_cfg
	for file_cfg in ${WDS_LIST_FILENAME_CFG}; do
		
		# Pega as informações dos arquivos de configuração
		name_cfg=$( echo "${file_cfg}" | cut -d':' -f 1 )
		path_cfg=$( echo "${file_cfg}" | cut -d':' -f 2 )
		
		
		# Verifica se a instalação foi realizada corretamente
		is_valid=`echo $( verifyKeyValidation "${WDS_DIR_CONFIG}/${path_cfg}" )`
		if [ "${is_valid}" = false ]; then
			
			writeLog '[ERRO] Arquivo de configuração inválido'
			writeLog "	- O arquivo de configuração { ${name_cfg} } é inválido, ele foi alterado ou excluído"
			
			show "Arquivo de configuração inválido. \nO arquivo de configuração { ${name_cfg} } é inválido, ele foi alterado ou excluído."
							
			exit 1
		fi
		
	done
		
}


app_is_installed()
{
# Verifica se a instalação já foi realizada
if ! ls "${WDS_DIR_CONFIG}/${WDS_FILENAME_INSTALL_APP}" > /dev/null 2>&1; then
	
	echo ""
	echo " - Para usar, primeiro realize a instalação desta aplicação."
	echo " - Para instalar execute o comando:"
	echo " > ${WDS_FILENAME_SCRIPT_WDS} INSTALL APP"
	echo ""
	
	exit 1
	
fi


# Verifica se todos os diretórios foram criados com sucesso
for dir in ${WDS_DIR_LIST}; do

	# Verifica se os diretórios foram criados
	if ! ls "${dir}" > /dev/null 2>&1; then
		
		echo '[ERRO] Diretório de instalação em falta'
		echo "	- Diretório: ${dir}"
		echo "	Reinstale a aplicação, comando: ${WDS_FILENAME_SCRIPT_WDS} REINSTALL APP"
	
		exit 1
		
	fi

done
}


################################################################################################################
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////#
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////#
#/////////////////////////////// --- INICIO EXECUÇÃO DA APLICAÇÃO --- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\#
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\#
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\#
################################################################################################################



#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#|--------------------------- Inicio Variáveis de Inicialização do Script ------------------------------------|
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


	# Carrega bash_profile.
	if [ -f ${HOME}/.bash_profile ]; then
		. ${HOME}/.bash_profile
	else
		if [ -f ${HOME}/.profile ]; then
			. ${HOME}/.profile
		fi
	fi
	
	# Verifica se a variável do diretório de instalação foi declarada
	if [ -z "${WDS_SKILL_TOOLS}" ]; then
		echo ''
		echo "[ERROR] Declare e export o caminho da aplicacao na variavel WDS_SKILL_TOOLS no .bash_profile"
		echo ''
		exit 1
	fi


	# Nome do diretório onde a aplicação está instalada
	WDS_APP_DIRNAME="${WDS_SKILL_TOOLS}"
	export WDS_APP_DIRNAME
	
	# Realiza a criacao dos arquivos com permissao leitura e escrita para Owner e Grupo
	umask 007
	
	# Carrega as variáveis
	loadVariables
	
	# Verifica se a aplicação está instalada
	app_is_installed
	
	# Realiza a validação inicial da aplicação
	__VALID_APP__
	
	
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#|--- Informar o nome da função a ser iniciada ---------------------------------------------------------------|
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

	
	

WDS_ORIGEM_ACCESS="TELEGRAM"
export WDS_ORIGEM_ACCESS
startTelegram "${1}"


