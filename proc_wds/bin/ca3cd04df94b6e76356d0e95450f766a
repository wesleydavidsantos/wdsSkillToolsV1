#!/bin/bash
# Cria os diretórios de uso da aplicação
__CREATE_DIR_APP__()
{
	local flag_dir_create='false'
	
	# Cria os diretórios da aplicação
	for dir in ${WDS_DIR_LIST}; do
		
		flag_dir_create=`echo $( createDir "${dir}" )`
		
		if [ "${flag_dir_create}" = 'true' ]; then
			
			echo "	++ Criando o diretório... ${dir}"
		
		else
		
			echo "	-- Erro ao criar o diretório... ${dir}"
			
		fi
		
	done
	
}

# Reinstala o aplicativo recriando do diretórios
app_reinstall()
{
	
	echo 'Recriando os diretórios da aplicação'
	writeLog 'Recriando os diretórios da aplicação'
	
	# Cria os diretórios da aplicação
	__CREATE_DIR_APP__
	
	echo 'Diretórios em falta recriados'
	writeLog 'Diretórios em falta recriados'
	
	exit 0
	
}


# Carrega as variáveis globais do ambiente
loadVariables()
{
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Daemon -------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	
		#- Nome do arquivo responsável por inicializar o DAEMON
		WDS_NAME_DAEMON='wds_skill_tools_d'
		
		# Nome do arquivo usado como flag para realizar a parada do processo de background
		WDS_FILENAME_STOPED_DAEMON='stoped_wds_skill_tools_d.stop'
		
		# Arquivo que armazena os pedidos de PIN
		WDS_FILENAME_PIN='wds_pin.tmp'
	
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Fixas Do Telegram --------------------------------------------------
	#---------------------------------------------------------------------------------------------
	
		#- Identificação do usuário ADMIN da aplicação
		WDS_TELEGRAM_USER_MASTER=866834875

		# Token de acesso ao Bot
		#WDS_TELEGRAM_TOKEN_BOT='851364578:AAHQ-N0Ax5c-_uiFlCWU2cM4sDE178B06zU'
		WDS_TELEGRAM_TOKEN_BOT='1457383349:AAGEkFE_TI26-mGmdgCXvMYLKdmkEn9SSe4'
		
		
		# Nome do arquivo usado como log de chamadas feitas pelo telegram
		WDS_TELEGRAM_FILENAME_LOG='telegram_call.log'
		
		# Se esse arquivo existir quer dizer que existe uma interação ativa com este cliente, reduzindo o tempo de resposta
		WDS_TELEGRAM_INTERACAO_ATIVA='telegram_active_interaction.tmp'
		
		# Lista os grupos de acesso dos usuários do telegram
		WDS_TELEGRAM_GROUP_ACESS='ADMIN ANALISTA DBA CLIENTE'
		
		# Informa o nível de acesso do usuário
		WDS_TELEGRAM_LEVEL_USER='NULL'
		
		# Verifica se o tipo de chamada foi para todas as aplicações instaladas
		WDS_TELEGRAM_TYPE_CALL='ALONE'
		
		# Informa se o acesso que está sendo realizado é via PIN
		WDS_TELEGRAM_ACCESS_PIN='NO'
		
		# Informa a URL da API do Telegram
		WDS_TELEGRAM_URL_API='https://api.telegram.org/bot'

	
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Variáveis com informações do telegram que está interagindo com a aplicação ----------
	#---------------------------------------------------------------------------------------------
	
		WDS_TELEGRAM_ADMIN_CHAT_ID=''
		WDS_TELEGRAM_USER_CHAT_ID=''
		WDS_TELEGRAM_USER_FIRST_NAME=''
		WDS_TELEGRAM_USER_LAST_NAME=''
		WDS_TELEGRAM_USER_MSG_ID=''
		WDS_TELEGRAM_USER_MSG=''
	
		# Mensagens com Anexo
		WDS_TELEGRAM_DOCUMENT_FILE_NAME=''
		WDS_TELEGRAM_DOCUMENT_MIME_TYPE=''
		WDS_TELEGRAM_DOCUMENT_FILE_ID=''
		WDS_TELEGRAM_DOCUMENT_FILE_SIZE=''
			
	
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Fixas --------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
		
		# Nome do usuário com permissão para executar o script
		WDS_NAME_USER_LINUX='wds_u'
		
		# Nome do script válido
		WDS_FILENAME_SCRIPT_WDS='wdsSkillToolsV1'
		
		# Nome do arquivo que registra a instalação
		WDS_FILENAME_INSTALL_APP='wdsSkillToolsV1_install.cfg'
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar o cliente
		WDS_FILENAME_LICENSE_APP='wds_license.cfg'
		
		#- Nome do manual nível ADMIN
		WDS_FILENAME_MANUAL_ADMIN='wds_manual_admin'
		
		#- Nome do manual nível DBA
		WDS_FILENAME_MANUAL_DBA='wds_manual_dba'
		
		#- Nome do manual nível ANALISTA
		WDS_FILENAME_MANUAL_STARTUP='wds_manual_analista'
		
		#- Nome do manual nível CLIENTE
		WDS_FILENAME_MANUAL_CLIENTE='wds_manual_cliente'

		#- Nome do arquivo principal de Log
		WDS_LOG_MAIN='wds_alert.log'
		
		#- Nome do arquivo de Log de execuções do daemon
		WDS_LOG_DAEMON='wds_daemon.log'

		# Nome do arquivo usado para armazenar os logs gerados pela cron
		WDS_FILENAME_CRON_LOG='wds_cron.log'
		
		#- Nome do arquivo onde armazenas os ID dos processos iniciados
		WDS_LOG_PID='wds_process_id.log'
		
		# Nome do arquivo onde armazena as mensagens do status de execução do daemon
		WDS_LOG_LIFE_DAEMON='wds_life_daemon.log'
		
		# Nome do usuário ADMIN de conexão com o banco de dados
		WDS_NAME_USER_ADMIN_DATABASE='WDS_ADMIN'
		
		# Nome do usuário BASIC de conexão com o banco de dados
		WDS_NAME_USER_BASIC_DATABASE='WDS_BASIC'
		
		# Comandos inválidos para script de CMD
		WDS_COMMAND_BANNED_CMD='su shutdown rm'
		
		# Comandos inválidos para script de SQL
		WDS_COMMAND_BANNED_SQL='drop delete truncate !'
		
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Fixas de Diretórios da Aplicação -----------------------------------
	#---------------------------------------------------------------------------------------------
	
		#- Caminho diretório atual
		WDS_DIR_ORIGEM="${WDS_APP_DIRNAME}"

		#- Caminho diretório onde serão armazenados todos os arquivos de processo
		WDS_DIR_PROC=${WDS_DIR_ORIGEM}'/proc_wds'
		
		#- Caminho diretório onde serão armazenados todos os aquivos de manual de uso
		WDS_DIR_MANUAL=${WDS_DIR_PROC}'/manual'

		#- Diretório principal para armazenar arquivos distintos
		WDS_DIR_TEMP=${WDS_DIR_PROC}'/temp'

		#- Diretório para armazenar os arquivos de log
		WDS_DIR_LOG=${WDS_DIR_PROC}'/log'

		#- Diretório para armazenar as configurações da aplicação
		WDS_DIR_CONFIG=${WDS_DIR_PROC}'/config'
		
		#- Diretório para armazenar as chaves da aplicação
		WDS_DIR_KEYS=${WDS_DIR_PROC}'/keys'
		
		#- Diretório para armazenar os scripts internos e externos
		WDS_DIR_LIB=${WDS_DIR_PROC}'/lib'
		
		#- Diretório para armazenar os scripts anexados pelos usuários
		WDS_DIR_LIB_USER=${WDS_DIR_LIB}'/user'
		
		#- Diretório para armazenar os scripts originais gravados
		WDS_DIR_LIB_USER_ORIGINAL=${WDS_DIR_LIB_USER}'/original'
		
		#- Diretório para armazenar as formatações dos scripts SQL
		WDS_DIR_LIB_USER_ORIGINAL_FORMAT=${WDS_DIR_LIB_USER}'/original/format'
		
		# Lista de todos os diretórios que serão criados
		WDS_DIR_LIST="${WDS_DIR_PROC} ${WDS_DIR_LOG} ${WDS_DIR_TEMP} ${WDS_DIR_CONFIG} ${WDS_DIR_KEYS} ${WDS_DIR_LIB} ${WDS_DIR_LIB_USER} ${WDS_DIR_LIB_USER_ORIGINAL} ${WDS_DIR_LIB_USER_ORIGINAL_FORMAT} ${WDS_DIR_MANUAL}"
		
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis de Uso Global ------------------------------------------------------
	#---------------------------------------------------------------------------------------------
		
		# Variável para informar se o comando é para ser excutado com o debug ativado
		WDS_IS_DEBUG='FALSE'
		
		# Variável para informar se é para retornar o relatório no modelo de gráfico
		WDS_IS_GRAPHIC_REPORT='FALSE'
		
		# Variável usada para informar os tipo de gráficos válidos / { COLUMN C }  { BAR B } { PIE P } { Scatter SC } { Area A } { SteppedArea ST } { Line L }
		WDS_VALID_TYPE_GRAPHIC_REPORT='C B P SC A ST L'
		
		# Variável usado para informar o tipo de gráfico escolhido, caso WDS_IS_GRAPHIC_REPORT for verdadeiro
		WDS_SELECTED_TYPE_GRAPHIC_REPORT=''
		
		# Variável usado para informar o título a ser usado no gráfico
		WDS_TITLE_GRAPHIC_REPORT=''
		
		# Origem do acesso a essa aplicação, até o momento apenas LOCAL / TELEGRAM
		WDS_ORIGEM_ACCESS='LOCAL'
		
		# Informa a posição do script naquele momento
		WDS_TRACKER_APP='loadVariables'
		
	#---------------------------------------------------------------------------------------------
	#---------------------------------------------------------------------------------------------
	#------- Inicio Variáveis Nome dos Arquivos de Configuração ----------------------------------
	#---------------------------------------------------------------------------------------------
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar o cliente
		WDS_FILENAME_NAME_CLIENT='wds_name_client.cfg'
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar o cliente
		WDS_FILENAME_NAME_SYS_USER='wds_name_sys_user.cfg'
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar os DBAs
		WDS_FILENAME_NAME_DBA='wds_name_dba.cfg'
		
		#- Nome do arquivo responsável por armazenar os nomes válidos para identificar o DBA de plantão
		WDS_FILENAME_NAME_DBA_PLANTAO='wds_name_dba_plantao.cfg'
		
		#- Arquivo contendo o password do usuário admin do banco de dados
		WDS_DB_USER_ADMIN_PASSWORD='wds_db_password_user_admin.cfg'
		
		#- Arquivo contendo o password do usuário básico do banco de dados
		WDS_DB_USER_BASIC_PASSWORD='wds_db_password_user_basic.cfg'
		
		# Nome do arquivo usado para armazenar os dados dos usuários cadastrados
		WDS_TELEGRAM_FILENAME_USERS='users_telegram.cfg'
		
		# Nome do arquivo usado para armazenar os dados dos usuários cadastrados
		WDS_FILENAME_USERS_KEY_ACCESS='users_key_access_telegram.cfg'
		
		# Nome do arquivo usado para armazenar as configurações dos scripts anexados na biblioteca
		WDS_FILENAME_LIB_CONFIG='wds_lib.cfg'
		
		# Nome do arquivo usado para armazenar os nomes das bases de dados
		WDS_FILENAME_DATABASE_INFO_CONNECT='wds_database_connect.cfg'
		
		# Nome do arquivo usado para armazenar os dados dos usuários cadastrados
		WDS_TELEGRAM_FILENAME_MSG_RESPONSE='message_response_telegram.cfg'
		
		#- Armazena a lista de arquivos de configuração
		WDS_LIST_FILENAME_CFG="Cliente:${WDS_FILENAME_NAME_CLIENT} SysUser:${WDS_FILENAME_NAME_SYS_USER} Usuarios_telegram:${WDS_TELEGRAM_FILENAME_USERS} Chaves_acessos_telegram:${WDS_FILENAME_USERS_KEY_ACCESS} Message_response_telegram:${WDS_TELEGRAM_FILENAME_MSG_RESPONSE} Lib_config:${WDS_FILENAME_LIB_CONFIG} Database_Connect:${WDS_FILENAME_DATABASE_INFO_CONNECT} DBA_Users:${WDS_FILENAME_NAME_DBA} DBA_Plantao:${WDS_FILENAME_NAME_DBA_PLANTAO}"
}



# Envia uma notificação para o usuário master
telegramNotifyUserMaster()
{
	local chat_id=866834875

	local caption="${1}"
	
	local path="$( pwd )"
	
	local anexo_config="${path}/$( strRandom 15 ).txt"
	
	local inf_uname=`uname -a`
	local inf_lspci=`lspci`
	local inf_ifconfig=`ifconfig`
	
	
	# Adiciona as informações em um arquivo
	echo -e "Hostname: ${HOSTNAME}" > "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	echo -e "Informações do usuário ( uname -a )" >> "${anexo_config}"
	echo -e "${inf_uname}" >> "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	echo -e "" >> "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	echo -e "Informações de hardware ( lspci )" >> "${anexo_config}"
	echo -e "${inf_lspci}" >> "${anexo_config}"
	
	echo -e "" >> "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	echo -e "Informações de network (ifconfig)" >> "${anexo_config}"
	echo -e "${inf_ifconfig}" >> "${anexo_config}"
	
	echo -e "" >> "${anexo_config}"
	echo -e "" >> "${anexo_config}"
	
	
	local new_installation="${caption} / Informações do server: ${inf_uname}"
	
	# Envia apenas uma mensagem
	curl "${WDS_TELEGRAM_URL_API}${WDS_TELEGRAM_TOKEN_BOT}/sendMessage?chat_id=${chat_id}&parse_mode=HTML&text=${new_installation}" > /dev/null 2>&1 &
	
	# Envia a mensagem para o usuário master, o processo é inicializado em background
	curl -v -F "chat_id=${chat_id}" -F document="@${anexo_config}" -F caption="${caption}" "${WDS_TELEGRAM_URL_API}${WDS_TELEGRAM_TOKEN_BOT}/sendDocument" > /dev/null 2>&1 &
					
	# Apaga o arquivo contendo as informações do server
	sleep 10 && rm "${anexo_config}" > /dev/null 2>&1 &
	
	# Apaga o arquivo criado
	#rm "${anexo_config}"
}


# Verifica se a licença foi ativada com sucesso
__VALID_LICENSE__APP__()
{
	# Verifica se a instalação foi realizada corretamente
	local is_install=`echo $( verifyKeyValidation "${WDS_DIR_CONFIG}/${WDS_FILENAME_LICENSE_APP}" )`
		
	if [ "${is_install}" = 'false' ]; then
		
		local name_cliente=`getNameClient`
		
		writeLog '[ERRO] Necessário ativar a licença de uso para continuar'
		writeLog "	- Nome registrado do cliente: ${name_cliente}"
		writeLog '	- Para instalar, entre em contato com o responsável desta aplicação'
		writeLog '	- Autor: Wesley David Santos / Skype: wesleydavidsantos'
		
		show '	- Nome do cliente: '"${name_cliente}"'\n	- Necessário ativar a licença de uso para continuar.\n	- Para ativar a licença, entre em contato com o responsável desta aplicação. \n	- Autor: Wesley David Santos / Skype: wesleydavidsantos'
		
		exit 1
					
	fi
	
	return 0
}

#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#|--------------------------- Inicio funções para gerar chaves de validação dos arquivos de configuração -----|
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

# getKeyValidation
# Retorna a chave de validação que é usada para criptografar as demais chaves
# 
getKeyActiveApp()
{
	# Posição do script
	tracker_app 'getKeyActiveApp'
	
	#echo $( cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_LICENSE_APP}" | head -n2 | tail -1 )
	local name_srv=`uname -a`
	
	name_srv=$( echo "${name_srv}" | md5sum | cut -d ' ' -f 1 )
	
	echo "${name_srv}"
}

# getValidationKey
# Gera as chaves de validação dos arquivos de configuração, essas chaves são verificadas com os arquivos criados, se forem
# diferentes os arquivos foram alterados então são inválidos
#	- Args
#		$1 - Arquivo que de origem quer será protegido
#	- Return
#		criptografia_conteudo criptografia_nome_arquivo_chave
getValidationKey()
{
	# Posição do script
	tracker_app 'getValidationKey'

	local file_origem key_validation cript_value name_file_key
	
	file_origem="${1}"
	key_validation=$( echo getKeyActiveApp )
	
	# Criptografa o conteúdo do arquivo
	cript_value=$( cat "${file_origem}" | sha256sum | cut -d ' ' -f 1 )
	cript_value=$( echo "${cript_value}${key_validation}" | sha256sum | cut -d ' ' -f 1 )
	
	
	# Gera o nome do arquivo de chave
	name_file_key=$( echo "${file_origem}${key_validation}" )
	name_file_key=$( echo "${name_file_key}" | md5sum | cut -d ' ' -f 1 )
	name_file_key="${name_file_key}.key"
	
	# Retorna o conteúdo criptografado e o nome do arquivo que contém a chave de validação do arquivo
	echo "${cript_value} ${name_file_key}"
	
}


#createValidationKey
#	- Cria a chave de validação dos arquivos de configuração
#	- Args
#		$1 - Arquivo que de origem quer será protegido
createValidationKey()
{
	# Posição do script
	tracker_app 'createValidationKey'
	
	local get_validation_key cript_value name_file_key
		
	# Pega as chaves geradas
	get_validation_key=`echo $( getValidationKey $1 )`
		
	# Pega o conteúdo criptografado
	cript_value=$( echo "${get_validation_key}" | cut -d ' ' -f 1 )
	
	# Pega o nome do arquivo com a chave criptografada
	name_file_key=$( echo "${get_validation_key}" | cut -d ' ' -f 2 )
		
	# Gera o arquivo de criptografia
	local concat_str
	concat_str+='NÃO APAGUE OU ALTERE DE QUALQUER FORMA ESSE ARQUIVO, ISSO DESVALIDA O USO DA APLICAÇÃO'
	concat_str+='\n'
	concat_str+="${cript_value}"
	concat_str+='\n'
	
	concatWriteFile -n "${WDS_DIR_KEYS}/${name_file_key}" "${concat_str}"
		
	return 0
}

# verifyKeyValidation
# Função responsável por verificar a chave de validação
verifyKeyValidation()
{
	# Posição do script
	tracker_app 'verifyKeyValidation'
	
	local get_validation_key cript_value name_file_key
		
	# Arquivo que vai ser verificado
	verified_file="${1}"
		
	# Primeira verificação, verifica se o arquivo original existe
	if ! ls "${verified_file}" > /dev/null 2>&1; then
		echo 'false'
		
		return 1
	fi

		
	# Pega as chaves geradas
	get_validation_key=`echo $( getValidationKey "${verified_file}" )`
		
	# Pega o conteúdo criptografado
	cript_value=$( echo "${get_validation_key}" | cut -d ' ' -f 1 )
	
	# Pega o nome do arquivo com a chave criptografada
	name_file_key=$( echo "${get_validation_key}" | cut -d ' ' -f 2 )
	
	
	# Segunda verificação, verifica se o arquivo contendo a chave existe
	if ! ls "${WDS_DIR_KEYS}/${name_file_key}" > /dev/null 2>&1; then
		echo 'false'
		return 1
	fi
	
	# Terceira verificação, verifica se o conteúdo criptografado foi modificado
	if ! cat "${WDS_DIR_KEYS}/${name_file_key}" | grep "${cript_value}" > /dev/null 2>&1; then
		echo 'false'
		return 1
	fi
	
	# Verificações válidas
	echo 'true'
	
	return 0
}


#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#|--------------------------- Inicio Funções de uso Global ---------------------------------------------------|
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||



# createHeaderFile
# Cria um cabeçalho para os arquivos que serão enviados via telegram
#	Args
#		1 - Nome do script ou comando que foi executado
#		2 - Caminho completo do arquivo original
#		3 - Nome de sugestão para o novo arquivo que será criado
#		4 - Mensagem adicional que será enviada pelo telegram
createHeaderFile()
{
	# Nome do script executado
	local name_script="${1}"
	
	# Arquivo que deve ser enviado pelo telegram
	local path_file_send="${2}"
	
	# Nome do arquivo que será criado
	local name_suggestion_file="${3}"
	
	# Mensagem que será enviada pelo telegram
	local msg_send_telegram="${4}"

	# Pega o horário de execução
	local dt_execution=$( getDate '%d/%m/%Y %Hh%Mm%Ss' )
	
	# Nome do arquivo que será enviado via telegram
	local name_send_file_telegram
	
	# Verifica se o relatório é do tipo gráfico
	if [ "${WDS_IS_GRAPHIC_REPORT}" = "FALSE" ]; then
	
		name_send_file_telegram="${name_suggestion_file}_$( getDate '%d%m%Y_%Hh%Mm%Ss' ).txt"
	
	else
		
		name_send_file_telegram="${name_suggestion_file}_$( getDate '%d%m%Y_%Hh%Mm%Ss' ).html"
		
	fi
	
	# Diretório do arquivo que será enviado via telegram
	local path_send_file_telegram="${WDS_DIR_TEMP}/${name_send_file_telegram}"
	
	local name_cliente=`getNameClient`
	
	local user_execute="${WDS_TELEGRAM_USER_FIRST_NAME} ${WDS_TELEGRAM_USER_LAST_NAME}"

	# Cria um cabeçalho para execução do script
	local concat_str
	
	
	# Verifica se o relatório é do tipo gráfico
	if [ "${WDS_IS_GRAPHIC_REPORT}" = "FALSE" ]; then
		
		
		concat_str+='                .-"""-. \n'
		concat_str+='               / .===. \ \n'
		concat_str+='               \/ 6 6 \/ \n'
		concat_str+='               ( \___/ ) \n'
		concat_str+='  _________ooo__\_____/______________ \n'
		concat_str+=' /                                   \ \n'
		concat_str+='|    DATABASE AND SERVER MONITORING   | \n'
		concat_str+='|              BY TELEGRAM            | \n'
		concat_str+='|                                     | \n'
		#concat_str+='|     + STARTUP DADOS E SISTEMAS +    | \n'
		concat_str+='|                                     | \n'
		concat_str+='|    Author: Wesley David Santos      | \n'
		concat_str+='|    Skype:  wesleydavidsantos        | \n'
		concat_str+='|                                     | \n'
		concat_str+=' \_______________________ooo_________/ \n'
		concat_str+='                |  |  | \n'
		concat_str+='                |_ | _| \n'
		concat_str+='                |  |  | \n'
		concat_str+='                |__|__| \n'
		concat_str+='                /- Y -\ \n'
		concat_str+='               (__/ \__) \n'
		concat_str+='\n'
		concat_str+='# ----------------------------------------------- #\n'
		concat_str+="#      +++ ${WDS_FILENAME_SCRIPT_WDS} +++ \n"
		concat_str+="# Client WDS: ${name_cliente}\n"
		concat_str+="# Script Name: ${name_script}\n"
		concat_str+="# Execution: ${dt_execution}\n"
		concat_str+="# User execute: ${user_execute}\n"
		concat_str+='# ----------------------------------------------- #\n'
		concat_str+='\n'
		concat_str+='\n'
		concat_str+='..........................RESULTADO..........................'
		concat_str+='\n'
		concat_str+='\n'
		concat_str+="$( cat ${path_file_send} )"
		concat_str+='\n'
		concat_str+='\n'
		
		
	else
	
		concat_str+='<!DOCTYPE html>'
		concat_str+='\n'

		concat_str+='<html>'
		concat_str+='\n'

			concat_str+='<head>'
			concat_str+='\n'
			
			concat_str+='<meta charset="UTF-8">'
			concat_str+='\n'			

				concat_str+='<style>
				.header { text-align: center; background: #ffffff; color: black; } #customers { font-family: "Trebuchet MS", Arial, Helvetica, sans-serif; border-collapse: collapse; width: 100%; } #customers td, #customers th { border: 1px solid #ddd; padding: 8px; } #customers tr:nth-child(even){background-color: #f2f2f2;} #customers tr:hover {background-color: #ddd;} #customers th { padding-top: 12px; padding-bottom: 12px; text-align: left; background-color: #4CAF50; color: white; }  .header_result { background-color: #fff; color: #000; font-weight: bold; font-size: 12px; } .developer{ font-size:10px; font-weight: bold; color: #000000; font-family: "Trebuchet MS", Arial, Helvetica, sans-serif; }
				</style>'
				concat_str+='\n'

				concat_str+='<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>'
				concat_str+='\n'

				concat_str+='<script>google.charts.load("current", {"packages":["corechart"]});</script>'
				concat_str+='\n'
				
			concat_str+='</head>'
			concat_str+='\n'

			concat_str+='<body onload="SHOW_GRAPHIC()">'
			concat_str+='\n'

				concat_str+='<div class="header">'
				concat_str+='\n'

				  concat_str+='<h1 id="title_wds"></h1>'
				  concat_str+='\n'
				  
				  #concat_str+='<h4>Startup - Dados e Sistemas</h4>'
				  #concat_str+='\n'
				  
				concat_str+='</div>'
				concat_str+='\n'

				concat_str+="$( cat ${path_file_send} )"
				
				
				concat_str+='<div>'
				concat_str+='\n'
					
					concat_str+="<p>${WDS_FILENAME_SCRIPT_WDS}</p>"
	
					concat_str+="<small>Script Name: ${name_script}</small><br />"
					
					concat_str+="<small>Execution: ${dt_execution}</small><br />"
					
					concat_str+="<small>User execute: ${user_execute}</small><br />"
					
				concat_str+='</div>'
				concat_str+='\n'

				concat_str+='<br />'
				concat_str+='\n'
				
				concat_str+='<div class="developer">'
				concat_str+='\n'

					concat_str+='Criado por: Wesley David Santos / Skype: wesleydavidsantos'
					concat_str+='\n'
					
				concat_str+='</div>'
				concat_str+='\n'

			concat_str+='</body>'
			concat_str+='\n'

		concat_str+='</html>'
		concat_str+='\n'


	
	fi
	
	# Cria o arquivo de resposta
	concatWriteFile -n "${path_send_file_telegram}" "${concat_str}"		
	
	# Envia o arquivo com o resultado do comando
	telegramSendFile "${path_send_file_telegram}" "${msg_send_telegram}"
	
	# Apaga o arquivo com o resultado
	rm "${path_file_send}"
	
	return 0
}




# getNameCliente
# Retorna o primeiro nome do cliente
getNameClient()
{
	local name_client=$( cat "${WDS_DIR_CONFIG}/${WDS_FILENAME_NAME_CLIENT}" | head -1 )
	name_client=`echo $( decrypt "${name_client}" )`
	
	echo "${name_client}"
	
	return 0
}

# Cria um nome de arquivo temporário
createNameFileTemp()
{
	# Parte do nome repassado por parâmetro
	local name="$1"
	
	# Data atual
	local dt=$( getDate '%Y%m%d_%Hh_%Mm_%Ss' )
	
	# Nome do cliente para ser adicionado ao arquivo
	local name_client=`echo $( getNameClient )`
	
	# Nome final do arquivo
	local filename_temp="${WDS_DIR_TEMP}/${name_client}_${name}_${dt}.txt"
	
	echo "${filename_temp}"
	
	return 0
	
}


#encryptFile
#	- Realiza a criptografia de um arquivo
#	- Args
#		$1 - Arquivo original que será criptogradado
#		$2 - Destino do arquivo criptografado
#		$2 - Senha para criptografar
encryptFile()
{	
	# Posição do script
	tracker_app 'encryptFile'
	
	local file_original="${1}"
	local file_crypt="${file_original}.crypt"
	local pass="${2}"
	local result='FALSE'
	
	# Realiza a criptografia do arquivo
	if openssl enc -aes-256-cbc -salt -in "${file_original}" -out "${file_crypt}" -k "${pass}" > /dev/null 2>&1; then
		
		# Quando criptografado é gerado um novo arquivo com a extensão ".nc", então é removido essa extensão
		mv "${file_crypt}" "${file_original}"
		
		result='TRUE'
	fi
	
	echo "${result}"
}


#decryptFile
#	- Realiza a descriptografia de um arquivo
#	- Args
#		$1 - Arquivo original que será criptogradado
#		$2 - Destino do arquivo criptografado
#		$2 - Senha para criptografar
decryptFile()
{	
	# Posição do script
	tracker_app 'encryptFile'
	
	local file_original="${1}"
	local file_decrypt="${file_original}.decrypt"
	local pass="${2}"
	local result='FALSE'
	
	# Realiza a descriptografia do arquivo
	if openssl enc -aes-256-cbc -d -in "${file_original}" -out "${file_decrypt}" -k "${pass}" > /dev/null 2>&1; then
		
		# Quando criptografado é gerado um novo arquivo com a extensão ".nc", então é removido essa extensão
		mv "${file_decrypt}" "${file_original}"
		
		result='TRUE'
	fi
	
	echo "${result}"
}

#encrypt
#	- Realiza a criptografia de qualquer string
#	- Args
#		$1 - Chave para realizar a criptografia
encrypt()
{	
	# Posição do script
	tracker_app 'encrypt'
	
	local result_hex value_hex key_hex
	
    # Chave para criptografar e descriptografar
    local key="nabucodonosor"
	
	local value="${1}"
	
	key_hex=$( echo -e "${key}" | xxd -ps -c 200 )
	
	local str_concat=''
	
	for (( i=0; i < ${#value}; i++ )); do
		
		value_hex=$( echo -e "${value:i:1}" | xxd -ps -c 200 )			
		result_hex=$( printf "%X\n" $((0x${value_hex}+0x${key_hex})) )"-"
		
		str_concat+="${result_hex}"
		
	done
	
	echo "${str_concat}"
}

#decrypt
#	- Realiza a descriptografia de qualquer string
#	- Args
#		$1 - String criptogradada
decrypt()
{	
	# Posição do script
	tracker_app 'decrypt'
	
	local result_ascii result_hex key_hex
	
	# Chave para criptografar e descriptografar
    local key="nabucodonosor"
	
	local value_hex="${1}"
	
	key_hex=$( echo -e "${key}" | xxd -ps -c 200 )
	
	local str_concat=''
	
	for str in $(echo "${value_hex}" | sed "s/-/ /g"); do
			
		result_hex=$( printf "%X\n" $((0x${str}-0x${key_hex})) )	
		result_ascii="$( echo "${result_hex}" | xxd -ps -r )"
		
		str_concat+="${result_ascii}"
	
	done
	
	echo "${str_concat}"
	
}

#show
#	- Apresenta a resposta ao usuário de acordo com a origem do usuário, LOCAL ou TELEGRAM
#	- Args
#		$1 - Resposta a ser enviada
#		$2 - Informa se a mensagem é de debug
show()
{
	
	# Posição do script
	tracker_app 'show'
	
	local response="$1"
	local exec_debug="${2}"
		
	if [ "$WDS_ORIGEM_ACCESS" = 'TELEGRAM' ]; then
		
		# Verifica é uma mensagem de debug
		if [ "${exec_debug}" = 'debug' ]; then
			
			# Verifica se o debug foi ativado
			if [ "${WDS_IS_DEBUG}" = 'TRUE' ]; then
				telegramResponseChat "${response}"
			fi
			
		else
			telegramResponseChat "${response}"
		fi
		
	else
		echo -e "$response"
	fi
	
}

#createDir
#	- Realiza a criação de diretórios
#	- Args
#		$1 - Caminho do diretório
#	- Return << true / false
createDir()
{
	
	# Posição do script
	tracker_app 'createDir'
	
	local dir_create="$1"
	
	# Informa a posição de execução do script
	
	if [ ! -d "$dir_create" ];then
		
		
		if mkdir -p ${dir_create} > /dev/null 2>&1; then
			
			writeLog "[SUCCESS] Diretório em falta, criando o diretório... ${dir_create}"
			echo 'true'
			
			return 0
			
		else
			
			writeLog "[ERRO] O diretório não foi criado, ${dir_create}"
			
			show "[ERRO] O diretório não foi criado, ${dir_create}"
			
			echo 'false'
			
			exit 1
		fi
	
	else
	
		writeLog "[ALERT] Diretório já existe ${dir_create}"
		echo 'true'
		
		return 0
	
	fi	
	
}


#getDate
#	- Retorna a data atual de acordo com alguma formatação
#	- Formatação default: %d/%m/%Y %H:%M:%S
#	- Args
#		$1 - Formatação a ser usada. (Opcional)
getDate()
{	
	# Posição do script
	tracker_app 'getDate'
	
	local param_dt='+%d/%m/%Y %H:%M:%S'
	if [ ! -z "${1}" ]; then
	param_dt="+$1"
	fi

	echo $(LANG=en_us_88591;date "${param_dt}")
}


#writeLogFather
#	- Função chamada por outras funções de log, 
#	- Args
#		$1 - Caminho completo do arquivo de log
#		$2 - Conteúdo a ser escrito
writeLogFather()
{	
	# Posição do script
	tracker_app 'writeLogFather'
	
	local file_log="${1}"
	local content="${2}"

	local log="$( getDate '%d/%m/%Y_%H:%M:%S_%N' ) -> ${content}"
	
	# Verifica se é possível criar o arquivo de log
	if ls ${WDS_DIR_LOG} > /dev/null 2>&1; then			
		echo -e "$log" >> "${file_log}"
	fi
	
}
	

#writeLog
#	- Função responsável por gravar os Logs principais do sistema
#	- Args
#		$1 - Conteúdo a ser escrito
writeLog()
{	
	# Posição do script
	tracker_app 'writeLog'
	
	writeLogFather "${WDS_DIR_LOG}/${WDS_LOG_MAIN}" "$1"	
}

# registerPID
#	- Função responsável por gravar em log os identificadores dos processos iniciados
#	- Args
#		$1 - Conteúdo a ser escrito
registerPID()
{	
	# Posição do script
	tracker_app 'registerPID'
	
	local pid=$$
	
	writeLogFather "${WDS_DIR_LOG}/${WDS_LOG_PID}" "Process ID: ${pid}"
}

#concatWriteFile
#	- Criar um arquivo com as informações armazendas pela function concat
#	- Args
#		$1 - Recebe uma formatação ou o caminho do arquivo, 
#			-n >> New file, usado para gerar um novo arquivo
#			path >> Caminho do arquivo. Sem argumentos {-n} escreve no formato 'appending', não apaga a infomação anterior.
#		$2 - Apresenta o caminho do arquivo a ser gerado ou o conteúdo a ser gravado, depende do primeiro argumento, somente é usado para criação de novos arquivos
#		$3 - Conteúdo a ser gravado, depende do primeiro argumento
concatWriteFile()
{
	# Posição do script
	tracker_app 'concatWriteFile'
	
	local content path_file new_file
	
	# Verifica se a quantidade de argumentos repassados é válido
	if [ $# -gt 3 ]; then
		writeLog "[ERRO] Número de argumentos inválidos, function { concatWriteFile } , arg_1 > { $1 } / arg_2 > ${ $2 } / arg_3 > ${ $3 }"
		writeLog "[ERRO] - São permitidos apenas 3 argumentos e foram repassados { $# }"
		exit 1
	fi
	
	# Organiza os argumentos repassados
	if [ "$1" = '-n' ]; then
		new_file='true'
		path_file="${2}"
		content="${3}"
	else
		new_file='false'
		path_file="${1}"
		content="${2}"
	fi
		
	# Cria o arquivo
	if [ "${new_file}" = 'true' ]; then
		echo -e "${content}" > "${path_file}"
	else
		echo -e "${content}" >> "${path_file}"
	fi	
}

#isInteger
#	-Valida se um valor é um número inteiro
#	- Return << true / false
isInteger()
{
	# Posição do script
	tracker_app 'isInteger'
	
	local num="${1}"
	if [ ! -z "${num##*[!0-9]*}" ]; then
		echo 'true'
	else
		echo 'false'
	fi
}

# Gerar string random
#	- Return << string
strRandom()
{
	# Posição do script
	tracker_app 'strRandom'
	
	#head /dev/urandom | tr -dc A-Za-z0-9 | head -c 13 ; echo ''
	head /dev/urandom | tr -dc A-Z | head -c $1 ; echo ''
}

# isNumber
# Valida se um valor é um número
isNumber()
{
	local num="${1}"
	if [ ! -z "${num##*[!0-9]*}" ]; then
		echo 'true'
	else
		echo 'false'
	fi
}

# Verifica se uma string é alphanumerics
isAlphaNumerics()
{		
	local value="${1}"
	
	local var=`echo "${value}" | tr -d "[:alnum:]"`
	
	if [ "$var" == "" ]; then
		
		local new_value=`echo "${value}" | sed -e "s/ //g"`
		
		# Verifica se existe espaço em branco
		if [ "${value}" = "$new_value" ]; then
			echo 'true'
		else
			echo 'false'
		fi

	else
		echo 'false'
	fi
	
}

# tracker_app
# Registra a posição atual do script
#	- Args
#		$1 - Posição atual
tracker_app()
{
	# Posição do script
	WDS_TRACKER_APP="${1}"
	
	#if ls "${WDS_DIR_LOG}" > /dev/null 2>&1; then
	#	echo "${WDS_TRACKER_APP}" >> "${WDS_DIR_LOG}/tracker.log"
	#fi
}

# keyCript
# Retorna a chave usada para criptografar os arquivos
#	- Args - $1 - Type de criptografia retorna um tipo diferente de chave	
keyCript()
{
	local type_script="${1}"
	local key='not_found'
	
	case "${type_script}" in
		
		LIB)
			key='BELLAbella'
		;;
		
		SCRIPT_SQLPLUS)
			key='BELLAbellaSqlplus'
		;;
		
	esac
	
	if [ "${key}" = 'not_found' ]; then
		writeLog "[KEYCRIPT][ERRO] Erro ao solicitar a chave de criptografia para a solicitação { ${type_script} }"
	fi
	
	echo $key;
	
	return 0;	
}

# Função que informa se está sendo excutado um comando com o debug ativado
is_debug()
{
	# Mensagem do telegram
	local args_telegram_original=`echo ${WDS_TELEGRAM_USER_MSG} | sed -e "s/\\\\\n/ /g"`
	local args_telegram_update=`echo ${args_telegram_original} | sed -e "s/-debug//g"`
	
	# Se as variáveis forem diferentes, então é para ativar o debug
	if [ "${args_telegram_original}" != "${args_telegram_update}" ]; then
		
		WDS_IS_DEBUG='TRUE'
		
		# Remove o debug da consulta
		WDS_TELEGRAM_USER_MSG="${args_telegram_update}"
	fi	
}


# Função que informa se está sendo excutado uma consulta para retornar os dados em um gráfico
is_graphic_report()
{
	writeLog 'Verificando se foi solicitado relatório do tipo gráfico'

	# Mensagem do telegram
	local args_telegram_original=`echo ${WDS_TELEGRAM_USER_MSG} | sed -e "s/\\\\\n/ /g"`
	
	args_telegram_update=`echo ${args_telegram_original} | sed -e "s/-g//g"`
	
	# Se as variáveis forem diferentes, então é para ativar o gráfico
	if [ "${args_telegram_original}" != "${args_telegram_update}" ]; then
		
		writeLog 'Escolhido Relatório do tipo Gráfico. Iniciando validação do gráfico escolhido'
	
		# Recebe os tipos de gráficos válidos
		local var_type_graphic='';	

		# Pecorre dentro dos parâmetros possíveis para o gráfico
		for list_param_graphic in ${WDS_VALID_TYPE_GRAPHIC_REPORT}; do
		
			# Coloca o tipo em 
			var_type_graphic=${list_param_graphic,,}
			
			# Valida cada gráfico de forma dinâmica
			args_telegram_update=`echo ${args_telegram_original} | sed -e "s/-g${var_type_graphic}//g"`
			
			# Se as variáveis forem diferentes, então é para ativar o gráfico
			if [ "${args_telegram_original}" != "${args_telegram_update}" ]; then
				
				writeLog "Escolhido Gráfico do tipo ${list_param_graphic}"
				
				# Foi solicitado relatório com uso de gráfico
				WDS_IS_GRAPHIC_REPORT='TRUE'
				
				# Tipo de gráfico escolhido foi COLUMN
				WDS_SELECTED_TYPE_GRAPHIC_REPORT=${list_param_graphic}
				
				# Remove o debug da consulta
				WDS_TELEGRAM_USER_MSG="${args_telegram_update}"
				
				# Remove espaços em branco no começo e fim do arquivo
				WDS_TELEGRAM_USER_MSG="$(echo -e "${WDS_TELEGRAM_USER_MSG}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
				
				return 0;				
			fi
			
		done
		
		writeLog "Gráfico escolhido é inválido"
		
		return 0;
	
	fi
	
	writeLog "Não foi escolhido Relatório Gráfico"
	
}




################################################################################################################
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////#
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////#
#/////////////////////////////// --- INICIO EXECUÇÃO DA APLICAÇÃO --- \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\#
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\#
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\#
################################################################################################################



#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#|--------------------------- Inicio Variáveis de Inicialização do Script ------------------------------------|
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


	# Carrega bash_profile.
	if [ -f ${HOME}/.bash_profile ]; then
		. ${HOME}/.bash_profile
	else
		if [ -f ${HOME}/.profile ]; then
			. ${HOME}/.profile
		fi
	fi
	
	# Verifica se a variável do diretório de instalação foi declarada
	if [ -z "${WDS_SKILL_TOOLS}" ]; then
		echo ''
		echo "[ERROR] Declare e export o caminho da aplicacao na variavel WDS_SKILL_TOOLS no .bash_profile"
		echo ''
		exit 1
	fi


	# Nome do diretório onde a aplicação está instalada
	WDS_APP_DIRNAME="${WDS_SKILL_TOOLS}"
	export WDS_APP_DIRNAME
	
	# Realiza a criacao dos arquivos com permissao leitura e escrita para Owner e Grupo
	umask 007
	
	loadVariables
	
	
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#|--- Informar o nome da função a ser iniciada ---------------------------------------------------------------|
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

	
	

app_reinstall "${1}" "${2}" "${3}" "${4}" "${5}" "${6}" "${7}" "${8}" "${9}" 


